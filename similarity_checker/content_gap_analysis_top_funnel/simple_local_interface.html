<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Direct Content Gap Analyzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .config-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .config-row {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }

        .config-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .config-input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }

        .config-input:focus {
            border-color: #4facfe;
            outline: none;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 20px;
            margin-bottom: 30px;
            align-items: center;
        }

        .source-selector {
            display: flex;
            gap: 10px;
        }

        .source-btn {
            padding: 12px 24px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .source-btn.active {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }

        .test-btn, .analyze-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .test-btn {
            background: #f39c12;
            color: white;
        }

        .test-btn:hover {
            background: #d68910;
            transform: translateY(-2px);
        }

        .analyze-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1.1rem;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .analyze-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }

        .status-indicator.connected {
            background: #28a745;
        }

        .results-container {
            margin-top: 30px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.1rem;
            color: #666;
        }

        .gap-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border: 3px solid #4facfe;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            position: relative;
        }

        .gap-badge {
            position: absolute;
            top: -10px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .gap-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            padding-right: 100px;
        }

        .gap-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .detail-item {
            background: rgba(255,255,255,0.7);
            padding: 10px;
            border-radius: 8px;
        }

        .detail-label {
            font-weight: 600;
            color: #34495e;
            font-size: 0.9rem;
        }

        .detail-value {
            color: #2c3e50;
            margin-top: 5px;
        }

        .similar-content {
            margin-top: 15px;
        }

        .similar-item {
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .statistics {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #d35400;
        }

        .stat-label {
            font-size: 1.1rem;
            color: #8e44ad;
            margin-top: 5px;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .loading {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Direct Content Gap Analyzer</h1>
            <p>Query your local Qdrant database directly with JavaScript - No server needed!</p>
        </div>

        <div class="content">
            <!-- Configuration Panel -->
            <div class="config-panel">
                <h3>üîß Configuration</h3>
                <div class="config-row">
                    <label class="config-label">OpenAI API Key:</label>
                    <input type="password" id="openai-key" class="config-input" placeholder="sk-..." 
                           value="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">
                </div>
                <div class="config-row">
                    <label class="config-label">Qdrant Host:</label>
                    <input type="text" id="qdrant-host" class="config-input" placeholder="localhost"
                           value="localhost">
                </div>
                <div class="config-row">
                    <label class="config-label">Qdrant Port:</label>
                    <input type="number" id="qdrant-port" class="config-input" placeholder="6333"
                           value="6333">
                </div>
                <div style="margin-top: 10px; padding: 10px; background: rgba(79, 172, 254, 0.1); border-radius: 8px; font-size: 0.9rem;">
                    <strong>üìä Qdrant Dashboard:</strong><br>
                    <a href="http://localhost:6333/dashboard#/collections/filestack" target="_blank" style="color: #4facfe;">Filestack Collection</a> | 
                    <a href="http://localhost:6333/dashboard#/collections/froala" target="_blank" style="color: #4facfe;">Froala Collection</a> |
                    <a href="http://localhost:6333/dashboard#/collections/content_gaps" target="_blank" style="color: #28a745;">Content Gaps Collection</a>
                </div>
            </div>

            <!-- Connection Status Panel -->
            <div class="status-panel">
                <h3>üîß System Status</h3>
                <div class="status-item">
                    <div class="status-indicator" id="openai-status"></div>
                    <span>OpenAI API</span>
                    <span id="openai-text">Not tested</span>
                </div>
                <div class="status-item">
                    <div class="status-indicator" id="qdrant-status"></div>
                    <span>Qdrant Database</span>
                    <span id="qdrant-text">Not tested</span>
                </div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <div class="source-selector">
                    <button class="source-btn active" data-source="filestack">üìÅ Filestack</button>
                    <button class="source-btn" data-source="froala">üìù Froala</button>
                </div>
                <button class="test-btn" onclick="testConnections()">üîç Test Connections</button>
                <button class="analyze-btn" onclick="analyzeCustomIdea()" id="analyze-btn">
                    üéØ Analyze Content Gap
                </button>
            </div>

            <!-- Main Tools Row -->
            <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                <!-- Content Gap Analysis Card -->
                <div style="flex: 1; background: #f8f9fa; border-radius: 15px; padding: 20px;">
                    <h3>üéØ Content Gap Analysis</h3>
                    <p style="color: #666; margin-bottom: 15px;">
                        Enter your content idea to check if it's a gap or if similar content already exists.
                    </p>
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <input type="text" id="custom-idea" placeholder="e.g., Top 5 File Uploaders in EdTech" 
                               style="flex: 1; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                    </div>
                </div>

                <!-- Similar Ideas Generator Widget -->
                <div style="flex: 1; background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%); border-radius: 15px; padding: 20px; border: 2px solid #28a745;">
                    <h3>üí° Similar Ideas Generator</h3>
                    <p style="color: #155724; margin-bottom: 15px; font-weight: 500;">
                        Generate unique content variations from your draft idea
                    </p>
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                        <input type="text" id="similar-idea-input" placeholder="e.g., JavaScript Image Processing Tutorial" 
                               style="flex: 1; padding: 12px; border: 2px solid #c3e6cb; border-radius: 8px; font-size: 14px; background: white;">
                    </div>
                    <button onclick="generateSimilarUniqueIdeasWidget()" id="generate-ideas-widget-btn"
                            style="width: 100%; padding: 12px; background: #28a745; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.95rem; font-weight: 600;">
                        üöÄ Generate Similar Unique Ideas
                    </button>
                    <div style="margin-top: 10px; font-size: 0.85rem; color: #155724; text-align: center;">
                        Vector search ‚Üí GPT generates ideas ‚Üí Real verification (same as Content Gap!)
                    </div>
                </div>
            </div>

            <!-- Results Container -->
            <div class="results-container" id="results-container">
                <p style="text-align: center; color: #666; padding: 40px;">
                    Configure your API keys above, test connections, then enter a content idea to analyze!
                </p>
            </div>

            <!-- Similar Ideas Widget Results -->
            <div class="results-container" id="similar-ideas-results" style="display: none;">
                <div class="statistics">
                    <div class="stat-number">üí°</div>
                    <div class="stat-label">Similar Ideas Generator</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentSource = 'filestack';
        let analyzing = false;

        // Source selection
        document.querySelectorAll('.source-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.source-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSource = btn.dataset.source;
                console.log('Selected source:', currentSource);
            });
        });

        // Get configuration
        function getConfig() {
            return {
                openaiKey: document.getElementById('openai-key').value.trim(),
                qdrantHost: document.getElementById('qdrant-host').value.trim() || 'localhost',
                qdrantPort: parseInt(document.getElementById('qdrant-port').value) || 6333
            };
        }

        // Test OpenAI connection
        async function testOpenAI(apiKey) {
            try {
                const response = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'text-embedding-3-large',
                        input: 'test connection'
                    })
                });

                if (response.ok) {
                    return { status: 'connected', error: null };
                } else {
                    const error = await response.json();
                    return { status: 'disconnected', error: error.error?.message || 'Unknown error' };
                }
            } catch (error) {
                return { status: 'disconnected', error: error.message };
            }
        }

        // Test Qdrant connection (using CORS-enabled endpoint)
        async function testQdrant(host, port) {
            try {
                const qdrantUrl = `http://${host}:${port}/collections`;
                const response = await fetch(qdrantUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    const collections = data.result?.collections || [];
                    return { 
                        status: 'connected', 
                        error: null, 
                        collections: collections.map(c => c.name) 
                    };
                } else {
                    return { status: 'disconnected', error: `HTTP ${response.status}: ${response.statusText}` };
                }
            } catch (error) {
                return { status: 'disconnected', error: error.message };
            }
        }

        // Test connections
        async function testConnections() {
            console.log('Testing connections...');
            
            const config = getConfig();
            
            if (!config.openaiKey) {
                alert('Please enter your OpenAI API key first');
                return;
            }

            // Reset status
            document.getElementById('openai-status').classList.remove('connected');
            document.getElementById('qdrant-status').classList.remove('connected');
            document.getElementById('openai-text').textContent = 'Testing...';
            document.getElementById('qdrant-text').textContent = 'Testing...';

            // Test OpenAI
            const openaiResult = await testOpenAI(config.openaiKey);
            if (openaiResult.status === 'connected') {
                document.getElementById('openai-status').classList.add('connected');
                document.getElementById('openai-text').textContent = 'Connected ‚úÖ';
            } else {
                document.getElementById('openai-text').textContent = `Error: ${openaiResult.error}`;
            }

            // Test Qdrant
            const qdrantResult = await testQdrant(config.qdrantHost, config.qdrantPort);
            if (qdrantResult.status === 'connected') {
                document.getElementById('qdrant-status').classList.add('connected');
                document.getElementById('qdrant-text').textContent = 
                    `Connected ‚úÖ (Collections: ${qdrantResult.collections.join(', ')})`;
            } else {
                document.getElementById('qdrant-text').textContent = `Error: ${qdrantResult.error}`;
            }
        }

        // Generate embedding using OpenAI
        async function generateEmbedding(text, apiKey) {
            const response = await fetch('https://api.openai.com/v1/embeddings', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'text-embedding-3-large',
                    input: text
                })
            });

            if (!response.ok) {
                throw new Error(`OpenAI API error: ${response.status}`);
            }

            const data = await response.json();
            return data.data[0].embedding;
        }

        // Search Qdrant for similar content
        async function searchQdrant(embedding, collectionName, host, port, limit = 10) {
            const qdrantUrl = `http://${host}:${port}/collections/${collectionName}/points/search`;
            
            const response = await fetch(qdrantUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    vector: embedding,
                    limit: limit,
                    with_payload: true
                })
            });

            if (!response.ok) {
                throw new Error(`Qdrant search error: ${response.status}`);
            }

            const data = await response.json();
            return data.result;
        }

        // Get curated suggestions from the keyword-focused content gaps collection
        async function getSuggestionsFromGapsCollection(source, host, port, limit = 3) {
            try {
                console.log(`üîç Searching keyword content gaps collection for ${source} suggestions...`);
                
                const qdrantUrl = `http://${host}:${port}/collections/keyword_content_gaps/points/scroll`;
                
                const response = await fetch(qdrantUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filter: {
                            must: [
                                {
                                    key: "source",
                                    match: {
                                        value: source.toLowerCase()
                                    }
                                },
                                {
                                    key: "verified_unique",
                                    match: {
                                        value: true
                                    }
                                }
                            ]
                        },
                        limit: limit * 3, // Get more variety from keyword-focused gaps
                        with_payload: true
                    })
                });

                if (!response.ok) {
                    console.warn(`‚ö†Ô∏è Keyword content gaps collection not found (${response.status}), using fallback suggestions`);
                    return [
                        {
                            suggestion: `${source} - Complete Beginner's Guide`,
                            value_score: 7,
                            uniqueness_score: 8,
                            category: 'Tutorial',
                            difficulty: 'Beginner',
                            content_type: 'Guide',
                            target_audience: 'New developers',
                            rationale: 'Comprehensive guide for newcomers to get started'
                        },
                        {
                            suggestion: `Advanced ${source} Implementation Patterns`,
                            value_score: 8,
                            uniqueness_score: 9,
                            category: 'Best Practices',
                            difficulty: 'Advanced',
                            content_type: 'Tutorial',
                            target_audience: 'Experienced developers',
                            rationale: 'Advanced techniques and patterns for optimal implementation'
                        },
                        {
                            suggestion: `${source} - Troubleshooting Common Issues`,
                            value_score: 8,
                            uniqueness_score: 7,
                            category: 'Troubleshooting',
                            difficulty: 'Intermediate',
                            content_type: 'Guide',
                            target_audience: 'All developers',
                            rationale: 'Problem-solving focused content for common challenges'
                        }
                    ];
                }

                const data = await response.json();
                const gaps = data.result?.points || [];
                
                if (gaps.length === 0) {
                    console.log('‚ö†Ô∏è No content gaps found in collection, using fallback');
                    return [
                        {
                            suggestion: `${source} - Complete Beginner's Guide`,
                            value_score: 7,
                            category: 'Tutorial',
                            rationale: 'Comprehensive guide for newcomers'
                        },
                        {
                            suggestion: `Advanced ${source} Optimization Strategies`,
                            value_score: 8,
                            category: 'Best Practices', 
                            rationale: 'Advanced techniques for optimization'
                        },
                        {
                            suggestion: `${source} - Common Mistakes and How to Avoid Them`,
                            value_score: 8,
                            category: 'Troubleshooting',
                            rationale: 'Problem-solving focused content'
                        }
                    ];
                }

                // Sort by uniqueness confidence and similarity score, get diverse suggestions
                const topGaps = gaps
                    .sort((a, b) => {
                        // Prioritize high confidence unique content
                        const aScore = (a.payload.uniqueness_confidence === 'high' ? 2 : a.payload.uniqueness_confidence === 'medium' ? 1 : 0) - a.payload.similarity_score;
                        const bScore = (b.payload.uniqueness_confidence === 'high' ? 2 : b.payload.uniqueness_confidence === 'medium' ? 1 : 0) - b.payload.similarity_score;
                        return bScore - aScore;
                    })
                    .slice(0, limit)
                    .map(gap => ({
                        suggestion: gap.payload.title,
                        keyword_focus: gap.payload.keyword_focus,
                        primary_funnel_stage: gap.payload.primary_funnel_stage,
                        target_funnel_stages: gap.payload.target_funnel_stages || [gap.payload.primary_funnel_stage],
                        category: gap.payload.category || 'General',
                        difficulty: gap.payload.difficulty || 'intermediate',
                        content_type: gap.payload.content_type || 'guide',
                        target_audience: gap.payload.target_audience || 'developers',
                        value_proposition: gap.payload.value_proposition || 'Valuable content opportunity',
                        uniqueness_angle: gap.payload.uniqueness_angle || 'Unique approach',
                        keywords: gap.payload.keywords || [gap.payload.keyword_focus],
                        uniqueness_confidence: gap.payload.uniqueness_confidence || 'medium',
                        similarity_score: gap.payload.similarity_score || 0.0,
                        keyword_category: gap.payload.keyword_category || 'general'
                    }));

                console.log(`‚úÖ Found ${topGaps.length} curated content gap suggestions`);
                return topGaps;

            } catch (error) {
                console.error('Error getting suggestions from gaps collection:', error);
                // Fallback suggestions
                return [
                    {
                        suggestion: `${source} - Complete Beginner's Guide`,
                        value_score: 7,
                        category: 'Tutorial',
                        rationale: 'Comprehensive guide for newcomers (fallback)'
                    },
                    {
                        suggestion: `Advanced ${source} Optimization Strategies`,
                        value_score: 8,
                        category: 'Best Practices',
                        rationale: 'Advanced techniques for optimization (fallback)'
                    },
                    {
                        suggestion: `${source} - Common Mistakes and How to Avoid Them`, 
                        value_score: 8,
                        category: 'Troubleshooting',
                        rationale: 'Problem-solving focused content (fallback)'
                    }
                ];
            }
        }

        // Use GPT-4o-mini to calculate semantic title similarity (with batching for large lists)
        async function calculateTitleSimilarity(idea, existingTitles, apiKey) {
            if (!existingTitles || existingTitles.length === 0) return [];
            
            // For large lists, process in smaller batches to avoid token limits
            const maxBatchSize = 20; // Reduced from unlimited to prevent token overflow
            
            if (existingTitles.length <= maxBatchSize) {
                return await calculateTitleSimilarityBatch(idea, existingTitles, apiKey);
            } else {
                // Process in batches
                const allScores = [];
                for (let i = 0; i < existingTitles.length; i += maxBatchSize) {
                    const batch = existingTitles.slice(i, i + maxBatchSize);
                    const batchScores = await calculateTitleSimilarityBatch(idea, batch, apiKey);
                    allScores.push(...batchScores);
                }
                return allScores;
            }
        }
        
        // Process a single batch of title similarities
        async function calculateTitleSimilarityBatch(idea, titleBatch, apiKey) {
            const prompt = `You are a content similarity expert. Compare the proposed content idea with existing article titles to determine semantic similarity.

PROPOSED IDEA: "${idea}"

EXISTING TITLES:
${titleBatch.map((title, i) => `${i + 1}. "${title}"`).join('\n')}

For each existing title, rate how similar it is to the proposed idea on a scale of 0.0 to 1.0, where:
- 1.0 = Essentially the same topic (duplicate content)
- 0.8-0.9 = Very similar topic with slight variation
- 0.6-0.7 = Related topic but different angle
- 0.4-0.5 = Somewhat related
- 0.0-0.3 = Different topics

Consider semantic meaning, not just word matching. For example:
- "How to install X" vs "Integrating X guide" = high similarity (~0.85)
- "React file upload" vs "File handling in React" = high similarity (~0.8)
- "Best practices for X" vs "X tutorial" = medium similarity (~0.6)

CRITICAL: Respond with ONLY a valid JSON array of exactly ${titleBatch.length} numbers, no explanations:
[0.85, 0.23, 0.91, 0.45]`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.1, // Low temperature for consistent scoring
                        max_tokens: 400  // Increased from 200 to handle larger arrays
                    })
                });

                if (!response.ok) {
                    console.error('GPT title similarity failed, falling back to basic matching');
                    return titleBatch.map(() => 0.3); // Fallback to medium similarity
                }

                const data = await response.json();
                let responseContent = data.choices[0].message.content.trim();
                
                // Clean up response more thoroughly
                if (responseContent.startsWith('```json')) {
                    responseContent = responseContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
                } else if (responseContent.startsWith('```')) {
                    responseContent = responseContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
                }
                
                // Remove any trailing text after the JSON array
                const arrayMatch = responseContent.match(/\[[\s\S]*?\]/);
                if (arrayMatch) {
                    responseContent = arrayMatch[0];
                }
                
                // Fix common JSON formatting issues
                responseContent = responseContent
                    .replace(/,\s*\]/g, ']') // Remove trailing commas
                    .replace(/,\s*,/g, ',') // Remove double commas
                    .replace(/\s+/g, ' ') // Normalize whitespace
                    .trim();

                // Check if JSON array is incomplete (missing closing bracket)
                if (responseContent.startsWith('[') && !responseContent.endsWith(']')) {
                    console.log('‚ö†Ô∏è Detected incomplete JSON array, attempting to fix...');
                    responseContent = responseContent + ']';
                }
                
                // Remove any trailing incomplete elements (e.g., ", 0" without closing)
                responseContent = responseContent.replace(/,\s*\d*\.?\d*\s*$/, ']').replace(/\]\]$/, ']');

                console.log('Cleaned JSON for parsing:', responseContent);
                
                const scores = JSON.parse(responseContent);
                
                // Ensure we have the right number of scores
                if (Array.isArray(scores)) {
                    if (scores.length < titleBatch.length) {
                        // Pad with default values if array is too short
                        while (scores.length < titleBatch.length) {
                            scores.push(0.3);
                        }
                    } else if (scores.length > titleBatch.length) {
                        // Truncate if array is too long
                        scores.splice(titleBatch.length);
                    }
                    return scores;
                } else {
                    return titleBatch.map(() => 0.3);
                }

            } catch (error) {
                console.error('Error calculating title similarity:', error);
                // Fallback to basic word matching
                return titleBatch.map(title => {
                    const ideaWords = new Set(idea.toLowerCase().split(/\s+/));
                    const titleWords = new Set(title.toLowerCase().split(/\s+/));
                    const intersection = new Set([...ideaWords].filter(x => titleWords.has(x)));
                    return intersection.size / Math.max(ideaWords.size, titleWords.size);
                });
            }
        }

        // Analyze content gap with GPT
        async function analyzeContentGap(idea, similarContent, source, apiKey) {
            // Extract titles for GPT-based similarity analysis
            const existingTitles = similarContent.map(item => item.payload.title || 'Unknown');
            
            console.log('Using GPT-4o-mini for intelligent title similarity analysis...');
            
            // Get semantic title similarities from GPT
            const titleSimilarities = await calculateTitleSimilarity(idea, existingTitles, apiKey);
            
            // Enhance content with AI-powered title similarity scores
            const enhancedContent = similarContent.map((item, index) => {
                const titleSim = titleSimilarities[index] || 0.3; // Fallback if GPT failed
                const contentSim = item.score;
                
                // Give title similarity much higher weight (70% title, 30% content)
                const combinedScore = (titleSim * 0.7) + (contentSim * 0.3);
                
                return {
                    ...item,
                    title_similarity: titleSim,
                    content_similarity: contentSim,
                    combined_score: combinedScore,
                    score: combinedScore // Override with combined score
                };
            });

            // Sort by combined score
            enhancedContent.sort((a, b) => b.combined_score - a.combined_score);
            
            const topSimilar = enhancedContent.slice(0, 5);
            // Industry-standard similarity thresholds
            const exactTitleMatches = topSimilar.filter(c => c.title_similarity >= 0.9);
            const highTitleSimilarity = topSimilar.filter(c => c.title_similarity >= 0.7 && c.title_similarity < 0.9);
            const highCombinedSimilarity = topSimilar.filter(c => c.combined_score >= 0.7);
            const veryHighCombinedSimilarity = topSimilar.filter(c => c.combined_score >= 0.8);

            let similarContext = "";
            
            if (exactTitleMatches.length > 0) {
                similarContext = "üö® EXACT/NEAR-EXACT TITLE MATCHES (‚â•90% title similarity - DUPLICATE CONTENT!):\n";
                similarContext += exactTitleMatches.map(c => 
                    `- '${c.payload.title}' (title: ${(c.title_similarity * 100).toFixed(1)}%, content: ${(c.content_similarity * 100).toFixed(1)}%, combined: ${(c.combined_score * 100).toFixed(1)}%)`
                ).join('\n');
                similarContext += "\nüõë CRITICAL: This is essentially duplicate content!\n";
            }
            
            if (highTitleSimilarity.length > 0) {
                if (similarContext) similarContext += "\n\n";
                similarContext += "üî¥ HIGH TITLE SIMILARITY (70-90% title match - very similar topics):\n";
                similarContext += highTitleSimilarity.map(c => 
                    `- '${c.payload.title}' (title: ${(c.title_similarity * 100).toFixed(1)}%, content: ${(c.content_similarity * 100).toFixed(1)}%, combined: ${(c.combined_score * 100).toFixed(1)}%)`
                ).join('\n');
            }
            
            if (veryHighCombinedSimilarity.length > 0 && exactTitleMatches.length === 0) {
                if (similarContext) similarContext += "\n\n";
                similarContext += "üö® VERY HIGH COMBINED SIMILARITY (‚â•80% - likely covers same topic):\n";
                similarContext += veryHighCombinedSimilarity.map(c => 
                    `- '${c.payload.title}' (title: ${(c.title_similarity * 100).toFixed(1)}%, content: ${(c.content_similarity * 100).toFixed(1)}%, combined: ${(c.combined_score * 100).toFixed(1)}%)`
                ).join('\n');
            }
            
            if (highCombinedSimilarity.length > 0 && veryHighCombinedSimilarity.length === 0 && exactTitleMatches.length === 0) {
                if (similarContext) similarContext += "\n\n";
                similarContext += "üü° HIGH COMBINED SIMILARITY (70-80% - related topics):\n";
                similarContext += highCombinedSimilarity.map(c => 
                    `- '${c.payload.title}' (title: ${(c.title_similarity * 100).toFixed(1)}%, content: ${(c.content_similarity * 100).toFixed(1)}%, combined: ${(c.combined_score * 100).toFixed(1)}%)`
                ).join('\n');
            }

            if (!similarContext) {
                similarContext = "No significant similarity found (all content <70% combined similarity).";
            }

            const prompt = `You are a content strategist analyzing content gaps for ${source}. 

CONTENT IDEA TO EVALUATE: "${idea}"

EXISTING SIMILAR CONTENT ANALYSIS (with title + content combined scoring):
${similarContext}

ENHANCED ANALYSIS INSTRUCTIONS (STRICT HIERARCHY):
1. üõë If EXACT TITLE MATCHES (‚â•90% title similarity) exist ‚Üí ALWAYS "SKIP THIS IDEA" (duplicate content)
2. üö® If HIGH TITLE SIMILARITY (‚â•70% title similarity) exists ‚Üí ALWAYS "SKIP THIS IDEA" (very similar topics)
3. üî¥ If VERY HIGH COMBINED SIMILARITY (‚â•80%) exists ‚Üí ALWAYS "SKIP THIS IDEA" (topic well-covered)
4. üü° If HIGH COMBINED SIMILARITY (70-79%) exists ‚Üí USUALLY "SKIP THIS IDEA" (likely redundant)
5. üü† If MEDIUM-HIGH COMBINED SIMILARITY (60-69%) exists ‚Üí CONSIDER "FILL THIS GAP" if truly unique angle
6. üü¢ If MEDIUM/LOW COMBINED SIMILARITY (<60%) ‚Üí "FILL THIS GAP" (clear content gap)

CRITICAL DECISION LOGIC:
- Title similarity ‚â•70% = AUTOMATIC SKIP (regardless of combined score)
- Combined similarity ‚â•70% = AUTOMATIC SKIP (regardless of title score)
- Both title AND combined under 70% = FILL GAP
- When any metric ‚â•70%, always SKIP to prevent duplicate content

Respond in this EXACT JSON format:
{
    "recommendation": "FILL THIS GAP" or "SKIP THIS IDEA",
    "reasoning": "Detailed explanation focusing on title similarity AND combined scores",
    "gap_score": 0.8,
    "content_angle": "Specific unique angle that differentiates from existing content",
    "target_audience": "Primary audience for this content",
    "content_type": "blog post, tutorial, guide, etc.",
    "differentiation": "How this differs from the most similar existing content"
}`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'gpt-4o-mini',
                    messages: [{ role: 'user', content: prompt }],
                    temperature: 0.3,
                    max_tokens: 600
                })
            });

            if (!response.ok) {
                throw new Error(`OpenAI Chat API error: ${response.status}`);
            }

            const data = await response.json();
            let responseContent = data.choices[0].message.content.trim();
            
            // Handle markdown code blocks - remove ```json and ``` wrapper
            if (responseContent.startsWith('```json')) {
                responseContent = responseContent.replace(/^```json\s*/, '').replace(/\s*```$/, '');
            } else if (responseContent.startsWith('```')) {
                responseContent = responseContent.replace(/^```\s*/, '').replace(/\s*```$/, '');
            }
            
            try {
                const analysisResult = JSON.parse(responseContent);
                
                // OVERRIDE GPT DECISION WITH DETERMINISTIC LOGIC
                // Apply industry-standard similarity thresholds
                const maxTitleSim = Math.max(...titleSimilarities);
                const maxCombinedSim = Math.max(...enhancedContent.map(c => c.combined_score));
                
                let finalRecommendation = analysisResult.recommendation;
                let overrideReason = null;
                
                // Apply strict industry-standard rules
                if (maxTitleSim >= 0.9) {
                    finalRecommendation = "SKIP THIS IDEA";
                    overrideReason = `AUTOMATIC SKIP: Exact title match detected (${(maxTitleSim * 100).toFixed(1)}% title similarity ‚â•90%)`;
                } else if (maxTitleSim >= 0.7) {
                    finalRecommendation = "SKIP THIS IDEA"; 
                    overrideReason = `AUTOMATIC SKIP: High title similarity (${(maxTitleSim * 100).toFixed(1)}% ‚â•70%)`;
                } else if (maxCombinedSim >= 0.7) {
                    finalRecommendation = "SKIP THIS IDEA";
                    overrideReason = `AUTOMATIC SKIP: High combined similarity (${(maxCombinedSim * 100).toFixed(1)}% ‚â•70%)`;
                } else {
                    finalRecommendation = "FILL THIS GAP";
                    overrideReason = `FILL GAP: Low similarity detected (max title: ${(maxTitleSim * 100).toFixed(1)}%, max combined: ${(maxCombinedSim * 100).toFixed(1)}%, both <70%)`;
                }
                
                if (overrideReason) {
                    console.log(`üîß LOGIC OVERRIDE: ${overrideReason}`);
                }
                
                // Return analysis with deterministic decision
                return {
                    ...analysisResult,
                    recommendation: finalRecommendation,
                    reasoning: overrideReason || analysisResult.reasoning,
                    max_title_similarity: maxTitleSim,
                    max_combined_similarity: maxCombinedSim,
                    enhanced_content: enhancedContent // Include the enhanced content with AI title similarities
                };
            } catch (e) {
                console.error('JSON parsing failed:', e);
                console.error('Raw response:', responseContent);
                return {
                    recommendation: "ERROR",
                    reasoning: `GPT response was not valid JSON: ${responseContent.substring(0, 200)}...`,
                    gap_score: 0.0,
                    content_angle: "Unable to analyze due to formatting error",
                    target_audience: "Unknown",
                    content_type: "Unknown",
                    differentiation: "Unable to determine",
                    enhanced_content: enhancedContent
                };
            }
        }

        // Main analysis function
        async function analyzeCustomIdea() {
            const ideaInput = document.getElementById('custom-idea');
            const idea = ideaInput.value.trim();
            
            if (!idea) {
                alert('Please enter a content idea to analyze');
                return;
            }

            const config = getConfig();
            if (!config.openaiKey) {
                alert('Please enter your OpenAI API key in the configuration section');
                return;
            }

            if (analyzing) return;
            analyzing = true;

            const analyzeBtn = document.getElementById('analyze-btn');
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'üîç Analyzing...';

            const resultsContainer = document.getElementById('results-container');
            resultsContainer.innerHTML = `
                <div class="loading">
                    üîç Generating embedding with OpenAI...<br/>
                    üìä Searching ${currentSource} database...<br/>
                    ü§ñ Analyzing with GPT-4o-mini...<br/>
                    ‚è±Ô∏è This may take a moment...
                </div>
            `;

            try {
                console.log('Starting analysis for:', idea);

                // Step 1: Generate embedding
                console.log('Generating embedding...');
                const embedding = await generateEmbedding(idea, config.openaiKey);
                console.log('Embedding generated, length:', embedding.length);

                // Step 2: Search Qdrant
                console.log('Searching Qdrant...');
                const collectionName = currentSource.toLowerCase();
                const searchResults = await searchQdrant(
                    embedding, 
                    collectionName, 
                    config.qdrantHost, 
                    config.qdrantPort, 
                    10
                );
                console.log('Search results:', searchResults.length);

                // Step 3: Analyze with GPT
                console.log('Analyzing with GPT...');
                const analysis = await analyzeContentGap(idea, searchResults, currentSource, config.openaiKey);
                console.log('Analysis complete:', analysis);

                // Note: Title similarity is now calculated within analyzeContentGap using GPT
                // We'll get the enhanced results from the analysis function

                // Get enhanced results from the analysis (with AI-powered title similarity)
                const enhancedResults = analysis.enhanced_content ? 
                    analysis.enhanced_content.slice(0, 5).map(r => ({
                        title: r.payload.title || 'Unknown',
                        url: r.payload.url || '',
                        score: r.combined_score,
                        title_similarity: r.title_similarity,
                        content_similarity: r.content_similarity,
                        combined_score: r.combined_score,
                        content_preview: (r.payload.content || '').substring(0, 200) + '...'
                    })) : [];

                // Display results
                displaySingleResult({
                    idea: idea,
                    source: currentSource,
                    recommendation: analysis.recommendation,
                    analysis: analysis,
                    similar_content: enhancedResults,
                    alternative_suggestions: analysis.alternative_suggestions,
                    max_similarity: enhancedResults.length > 0 ? enhancedResults[0].combined_score : 0.0,
                    similarity_analysis: {
                        high_similarity: enhancedResults.filter(r => r.combined_score >= 0.7 || r.title_similarity >= 0.7).length,
                        medium_similarity: enhancedResults.filter(r => (r.combined_score >= 0.5 && r.combined_score < 0.7) && (r.title_similarity < 0.7)).length,
                        low_similarity: enhancedResults.filter(r => r.combined_score < 0.5 && r.title_similarity < 0.5).length
                    }
                });

            } catch (error) {
                console.error('Analysis failed:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <h3>‚ùå Analysis Failed</h3>
                        <p>${error.message}</p>
                        <p>Make sure your API key is correct and Qdrant is running.</p>
                    </div>
                `;
            } finally {
                analyzing = false;
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = 'üéØ Analyze Content Gap';
            }
        }

        // Display single result (same as your existing function)
        function displaySingleResult(result) {
            const resultsContainer = document.getElementById('results-container');
            const analysis = result.analysis;
            const isGap = result.recommendation === 'FILL THIS GAP';
            
            let html = `
                <div class="statistics">
                    <div class="stat-number">${isGap ? '‚úÖ' : '‚ùå'}</div>
                    <div class="stat-label">${isGap ? 'Content Gap Found' : 'Content Already Exists'}</div>
                    <p style="margin-top: 10px; color: #8e44ad;">
                        Analysis for: "${result.idea}"
                    </p>
                </div>

                <div class="${isGap ? 'gap-card' : 'gap-card'}" style="${!isGap ? 'background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%); border-color: #e17055;' : ''}">
                    <div class="gap-badge" style="${!isGap ? 'background: #e17055;' : ''}">${isGap ? 'üéØ CONTENT GAP' : 'üìÑ SIMILAR EXISTS'}</div>
                    <div class="gap-title">${result.idea}</div>
                    
                    <div class="gap-details">
                        <div class="detail-item">
                            <div class="detail-label">Max Combined Similarity</div>
                            <div class="detail-value">${(result.max_similarity * 100).toFixed(1)}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Recommendation</div>
                            <div class="detail-value">${result.recommendation}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Gap Score</div>
                            <div class="detail-value">${(analysis.gap_score * 100).toFixed(0)}%</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Content Type</div>
                            <div class="detail-value">${analysis.content_type}</div>
                        </div>
                    </div>

                    <div class="detail-item">
                        <div class="detail-label">${isGap ? 'Why This is a Gap' : 'Why This is Not a Gap'}</div>
                        <div class="detail-value">${analysis.reasoning}</div>
                    </div>

                    ${isGap ? `
                        <div class="detail-item">
                            <div class="detail-label">Recommended Angle</div>
                            <div class="detail-value">${analysis.content_angle}</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">Target Audience</div>
                            <div class="detail-value">${analysis.target_audience}</div>
                        </div>
                        ${analysis.differentiation ? `
                        <div class="detail-item">
                            <div class="detail-label">How to Differentiate</div>
                            <div class="detail-value">${analysis.differentiation}</div>
                        </div>
                        ` : ''}
                    ` : ''}

                    <div class="similarity-analysis" style="margin-top: 15px;">
                        <div class="detail-label">Similarity Analysis</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 10px;">
                            <div class="detail-item">
                                <div class="detail-label">High (‚â•70%)</div>
                                <div class="detail-value">${result.similarity_analysis.high_similarity} articles</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Medium (50-69%)</div>
                                <div class="detail-value">${result.similarity_analysis.medium_similarity} articles</div>
                            </div>
                            <div class="detail-item">
                                <div class="detail-label">Low (<50%)</div>
                                <div class="detail-value">${result.similarity_analysis.low_similarity} articles</div>
                            </div>
                        </div>
                    </div>


                    ${result.similar_content.length > 0 ? `
                        <div class="similar-content">
                            <div class="detail-label">Most Similar Existing Content</div>
                            ${result.similar_content.map(content => `
                                <div class="similar-item">
                                    <strong>
                                        ${content.url ? `<a href="${content.url}" target="_blank" style="color: #2980b9; text-decoration: none;">${content.title} üîó</a>` : content.title}
                                    </strong> 
                                    <br>
                                    <div style="font-size: 0.9rem; margin-top: 5px;">
                                        <span style="color: ${content.title_similarity >= 0.9 ? '#e74c3c' : content.title_similarity >= 0.7 ? '#f39c12' : '#27ae60'};">
                                            üìù Title: ${(content.title_similarity * 100).toFixed(1)}%
                                        </span> | 
                                        <span style="color: ${content.content_similarity >= 0.7 ? '#e74c3c' : content.content_similarity >= 0.5 ? '#f39c12' : '#27ae60'};">
                                            üìÑ Content: ${(content.content_similarity * 100).toFixed(1)}%
                                        </span> | 
                                        <span style="color: ${content.combined_score >= 0.7 ? '#e74c3c' : content.combined_score >= 0.5 ? '#f39c12' : '#27ae60'};">
                                            üéØ Combined: ${(content.combined_score * 100).toFixed(1)}%
                                        </span>
                                    </div>
                                    <small style="color: #666;">${content.content_preview}</small>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;

            resultsContainer.innerHTML = html;
        }

        // Generate similar unique ideas based on user's draft
        async function generateSimilarUniqueIdeas() {
            const ideaInput = document.getElementById('custom-idea');
            const originalIdea = ideaInput.value.trim();
            
            if (!originalIdea) {
                alert('Please enter your content idea first');
                return;
            }

            const config = getConfig();
            if (!config.openaiKey) {
                alert('Please enter your OpenAI API key in the configuration section');
                return;
            }

            const generateBtn = document.getElementById('generate-ideas-btn');
            generateBtn.disabled = true;
            generateBtn.textContent = 'üîÑ Generating...';

            const resultsContainer = document.getElementById('results-container');
            resultsContainer.innerHTML = `
                <div class="loading">
                    üß† Vector search for relevant content...<br/>
                    üí° GPT generating unique alternatives...<br/>
                    üîç Real verification using Content Gap method...<br/>
                    ‚è±Ô∏è Ensuring 100% consistency...
                </div>
            `;

            try {
                console.log('Generating similar unique ideas for:', originalIdea);
                
                // Step 1: Find most relevant existing content for this idea (with full article data)
                const mostRelevantArticles = await findMostRelevantContentWithUrls(originalIdea, currentSource, config);
                
                // Step 2: Generate 5 similar but unique ideas using efficient vector approach
                const uniqueIdeas = await generateVerifiedUniqueIdeas(originalIdea, mostRelevantArticles, currentSource, config);
                
                // Step 3: CRITICAL: Filter out any ideas that match the original input exactly
                const filteredIdeas = uniqueIdeas.filter(idea => {
                    const similarity = calculateBasicSimilarity(idea.title.toLowerCase(), originalIdea.toLowerCase());
                    const isExactMatch = similarity > 0.9; // 90%+ similarity = too close to original
                    if (isExactMatch) {
                        console.log(`üö´ FILTERED OUT: "${idea.title}" - too similar to original input (${(similarity * 100).toFixed(1)}%)`);
                        return false;
                    }
                    return true;
                });
                
                console.log(`‚úÖ Filtered results: ${uniqueIdeas.length} ‚Üí ${filteredIdeas.length} unique ideas`);
                
                // Step 4: Display the properly filtered unique ideas
                displayGeneratedIdeas(originalIdea, filteredIdeas, currentSource);
                
            } catch (error) {
                console.error('Error generating similar unique ideas:', error);
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <h3>‚ùå Generation Failed</h3>
                        <p>${error.message}</p>
                        <p>Make sure your API key is correct and try again.</p>
                    </div>
                `;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'üí° Generate Similar Unique Ideas';
            }
        }

        // Find most relevant existing content for the idea
        async function findMostRelevantContent(idea, source, config, limit = 40) {
            try {
                // Generate embedding for the original idea
                const ideaEmbedding = await generateEmbedding(idea, config.openaiKey);
                
                // Search existing content using vector similarity
                const collectionName = source.toLowerCase();
                const searchResults = await searchQdrant(
                    ideaEmbedding,
                    collectionName,
                    config.qdrantHost,
                    config.qdrantPort,
                    limit
                );
                
                // Extract titles from search results
                const relevantTitles = searchResults.map(result => result.payload.title || 'Unknown');
                console.log(`Found ${relevantTitles.length} most relevant existing titles`);
                
                return relevantTitles;
                
            } catch (error) {
                console.error('Error finding relevant content:', error);
                return [];
            }
        }

        // EFFICIENT: Generate unique ideas using vector search + single GPT analysis
        async function generateVerifiedUniqueIdeas(originalIdea, relevantArticles, source, config, targetCount = 5) {
            console.log('üöÄ Using efficient vector-based approach for unique idea generation...');
            
            try {
                // Step 1: Convert original idea to vector
                const originalVector = await generateEmbedding(originalIdea, config.openaiKey);
                
                // Step 2: Get top similar content with full payload (already done in relevantArticles)
                const similarContent = relevantArticles.slice(0, 15); // Use top 15 for context
                
                // Step 3: Single GPT call to generate unique variations with similarity context
                const uniqueIdeas = await generateUniqueIdeasWithVectorContext(
                    originalIdea, 
                    similarContent, 
                    source, 
                    config.openaiKey, 
                    targetCount
                );
                
                console.log(`‚úÖ Generated ${uniqueIdeas.length} unique ideas efficiently`);
                return uniqueIdeas;
                
            } catch (error) {
                console.error('Efficient generation failed, falling back to original method:', error);
                // Fallback to original method if needed
                console.log('‚ö†Ô∏è Falling back to legacy method...');
                const relevantTitles = relevantArticles.map(a => a.title || 'Unknown');
                return await generateVerifiedUniqueIdeasLegacy(originalIdea, relevantTitles, source, config, targetCount);
            }
        }
        
        // Single efficient GPT call with vector search context
        async function generateUniqueIdeasWithVectorContext(originalIdea, similarContent, source, apiKey, targetCount = 5) {
            const serviceContext = source.toLowerCase() === 'froala' 
                ? 'Froala is a WYSIWYG rich text editor for web applications'
                : 'Filestack is a file upload, processing, and delivery service';
            
            const existingContent = similarContent.map((article, i) => 
                `${i + 1}. "${article.title}" (similarity: ${(article.score * 100).toFixed(1)}%)`
            ).join('\n');
            
            const prompt = `${serviceContext}

TASK: Generate ${targetCount} content ideas similar to the original but unique from existing content.

ORIGINAL IDEA: "${originalIdea}"

EXISTING SIMILAR CONTENT (vector search results):
${existingContent}

REQUIREMENTS:
1. Generate ideas similar in theme to the original
2. Ensure each is unique from the existing content above
3. NEVER generate the exact same title as the original idea
4. Focus on different angles, audiences, or approaches
5. No colons (:) in titles
6. Each must be practically valuable

CRITICAL: The original idea "${originalIdea}" should NOT appear in your results. Generate variations, not duplicates.

RESPOND with ONLY this JSON format:
[
  {
    "title": "Unique variation 1",
    "angle": "What makes it unique",
    "value_proposition": "Why valuable",
    "uniqueness_confidence": "high"
  }
]`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.6,
                        max_tokens: 800
                    })
                });

                if (!response.ok) throw new Error(`GPT API error: ${response.status}`);

                const data = await response.json();
                let responseContent = data.choices[0].message.content.trim();
                
                // Clean JSON
                if (responseContent.startsWith('```json')) {
                    responseContent = responseContent.replace('```json', '').replace('```', '');
                } else if (responseContent.startsWith('```')) {
                    responseContent = responseContent.replace(/```/g, '');
                }
                
                const ideas = JSON.parse(responseContent);
                
                // CRITICAL: Actually verify each idea using the SAME method as Content Gap Analyzer
                if (Array.isArray(ideas)) {
                    const verifiedIdeas = [];
                    for (const idea of ideas) {
                        // Use the EXACT same verification as Content Gap Analyzer
                        const verification = await verifyIdeaRealSimilarity(idea.title, similarContent, apiKey);
                        
                        if (verification.is_unique) {
                            verifiedIdeas.push({
                                ...idea,
                                uniqueness_verification: verification
                            });
                            console.log(`‚úÖ VERIFIED UNIQUE: ${idea.title} (${(verification.similarity * 100).toFixed(1)}% max similarity)`);
                        } else {
                            console.log(`‚ùå REJECTED IN VERIFICATION: ${idea.title} (${(verification.similarity * 100).toFixed(1)}% similarity to "${verification.most_similar}")`);
                        }
                    }
                    return verifiedIdeas;
                } else {
                    return [];
                }
                
            } catch (error) {
                console.error('Error in efficient generation:', error);
                return [];
            }
        }

        // Legacy: Generate and verify unique ideas iteratively (SLOW - kept as fallback)
        async function generateVerifiedUniqueIdeasLegacy(originalIdea, relevantTitles, source, config, targetCount = 5) {
            console.log('‚ö†Ô∏è Using legacy method - less efficient');
            const uniqueIdeas = [];
            let attempts = 0;
            const maxAttempts = 2; // Reduced attempts for fallback
            
            while (uniqueIdeas.length < targetCount && attempts < maxAttempts) {
                attempts++;
                console.log(`Legacy generation attempt ${attempts}/${maxAttempts}`);
                
                const generatedIdeas = await generateSimilarIdeasBatch(originalIdea, relevantTitles, source, config.openaiKey);
                
                for (const idea of generatedIdeas) {
                    if (uniqueIdeas.length >= targetCount) break;
                    
                    // Simplified uniqueness check for fallback
                    const isUnique = !relevantTitles.some(title => 
                        title.toLowerCase().includes(idea.title.toLowerCase().split(' ')[0])
                    );
                    
                    if (isUnique) {
                        idea.uniqueness_verification = {
                            is_unique: true,
                            confidence: 'medium',
                            similarity: 0.4,
                            method: 'legacy_fallback'
                        };
                        uniqueIdeas.push(idea);
                        console.log(`Legacy: Found idea: ${idea.title}`);
                    }
                }
            }
            
            return uniqueIdeas;
        }

        // Generate a batch of ideas similar to the original
        async function generateSimilarIdeasBatch(originalIdea, relevantTitles, source, apiKey) {
            const relevantContext = relevantTitles.slice(0, 30).map(title => `- ${title}`).join('\\n');
            
            // Define source context
            const sourceContext = source.toLowerCase() === 'froala' 
                ? 'Froala is a WYSIWYG rich text editor for web applications'
                : 'Filestack is a file upload, processing, and delivery service';
            
            const prompt = `${sourceContext}

Generate 8 content ideas that are SIMILAR in topic/theme to this original idea but with unique angles:

ORIGINAL IDEA: "${originalIdea}"

EXISTING CONTENT TO DIFFERENTIATE FROM:
${relevantContext}

REQUIREMENTS:
1. Stay close to the original topic but find unique angles
2. Avoid duplicating the existing content above
3. NEVER generate the exact same title as the original idea
4. No colons (:) in titles - use direct, clear titles
5. Focus on practical, valuable variations

Examples of good variations:
- Original: "JavaScript Image Processing Guide" ‚Üí "JavaScript Image Processing for Beginners"  
- Original: "File Upload Tutorial" ‚Üí "Secure File Upload Implementation"
- Original: "WYSIWYG Editor Setup" ‚Üí "Mobile-Optimized WYSIWYG Editor Setup"

Respond with ONLY a JSON array:
[{"title":"Similar idea 1","angle":"What makes it unique","value_proposition":"Why valuable"}]`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.6,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) throw new Error(`GPT API error: ${response.status}`);

                const data = await response.json();
                let responseContent = data.choices[0].message.content.trim();
                
                // Clean JSON
                if (responseContent.startsWith('```json')) {
                    responseContent = responseContent.replace('```json', '').replace('```', '');
                } else if (responseContent.startsWith('```')) {
                    responseContent = responseContent.replace(/```/g, '');
                }
                
                const ideas = JSON.parse(responseContent);
                return Array.isArray(ideas) ? ideas : [];
                
            } catch (error) {
                console.error('Error generating similar ideas:', error);
                return [];
            }
        }

        // Verify if an idea is unique using GPT title similarity + content embeddings (same method as Content Gap Analyzer)
        async function verifyIdeaUniqueness(idea, existingTitles, apiKey, threshold = 0.70) {
            try {
                console.log('üß† Using GPT-4o-mini for title similarity analysis (matching Content Gap method)...');
                
                // Step 1: Get semantic title similarities from GPT (same function as Content Gap Analysis)
                const titleSimilarities = await calculateTitleSimilarity(idea.title, existingTitles, apiKey);
                
                // Step 2: Generate content embedding for the idea
                const ideaEmbedding = await generateEmbedding(idea.title, apiKey);
                
                // Step 3: Generate embeddings for existing titles for content similarity
                const existingEmbeddings = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'text-embedding-3-large',
                        input: existingTitles
                    })
                });
                
                if (!existingEmbeddings.ok) throw new Error('Embedding generation failed');
                
                const embeddingsData = await existingEmbeddings.json();
                
                // Step 4: Calculate combined similarities (70% title + 30% content - same as Content Gap)
                let maxCombinedSimilarity = 0;
                let mostSimilar = '';
                let exactTitleMatch = false;
                
                embeddingsData.data.forEach((embedding, index) => {
                    const contentSimilarity = cosineSimilarity(ideaEmbedding, embedding.embedding);
                    const titleSimilarity = titleSimilarities[index] || 0.3;
                    
                    // Same weighting as Content Gap Analysis: 70% title + 30% content
                    const combinedSimilarity = (titleSimilarity * 0.7) + (contentSimilarity * 0.3);
                    
                    // Check for exact title matches (‚â•90% title similarity)
                    if (titleSimilarity >= 0.9) {
                        exactTitleMatch = true;
                    }
                    
                    if (combinedSimilarity > maxCombinedSimilarity) {
                        maxCombinedSimilarity = combinedSimilarity;
                        mostSimilar = existingTitles[index];
                    }
                });
                
                // Use same logic as Content Gap Analyzer
                const isUnique = !exactTitleMatch && maxCombinedSimilarity < threshold;
                const confidence = exactTitleMatch ? 'duplicate' : 
                                 maxCombinedSimilarity < 0.45 ? 'high' : 
                                 maxCombinedSimilarity < 0.65 ? 'medium' : 'low';
                
                console.log(`üìä Uniqueness check: ${idea.title} - Combined similarity: ${(maxCombinedSimilarity * 100).toFixed(1)}%${exactTitleMatch ? ' (EXACT TITLE MATCH!)' : ''}`);
                
                return {
                    is_unique: isUnique,
                    similarity: maxCombinedSimilarity,
                    most_similar: mostSimilar,
                    confidence: confidence,
                    exact_title_match: exactTitleMatch
                };
                
            } catch (error) {
                console.error('Error verifying uniqueness:', error);
                return { is_unique: true, similarity: 0.5, most_similar: 'verification_failed', confidence: 'low', exact_title_match: false };
            }
        }

        // Simple cosine similarity calculation
        function cosineSimilarity(vecA, vecB) {
            const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
            const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
            const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
            return dotProduct / (magnitudeA * magnitudeB);
        }
        
        // Basic word-based similarity calculation for filtering exact matches
        function calculateBasicSimilarity(text1, text2) {
            const words1 = new Set(text1.toLowerCase().split(/\s+/));
            const words2 = new Set(text2.toLowerCase().split(/\s+/));
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);
            return intersection.size / union.size; // Jaccard similarity
        }
        
        // EXACT SAME verification method as Content Gap Analyzer
        async function verifyIdeaRealSimilarity(ideaTitle, similarContent, apiKey) {
            try {
                // Extract titles for GPT-based similarity analysis (SAME as Content Gap Analyzer)
                const existingTitles = similarContent.map(item => item.title || 'Unknown');
                
                console.log(`üîç REAL VERIFICATION: "${ideaTitle}" against ${existingTitles.length} existing titles...`);
                
                // Get semantic title similarities from GPT (SAME function as Content Gap Analysis)
                const titleSimilarities = await calculateTitleSimilarity(ideaTitle, existingTitles, apiKey);
                
                // Generate content embedding for the idea
                const ideaEmbedding = await generateEmbedding(ideaTitle, apiKey);
                
                // Calculate combined similarities (70% title + 30% content - SAME as Content Gap)
                let maxCombinedSimilarity = 0;
                let mostSimilar = '';
                let exactTitleMatch = false;
                
                similarContent.forEach((item, index) => {
                    const contentSimilarity = item.score || 0.5; // Vector search score
                    const titleSimilarity = titleSimilarities[index] || 0.3;
                    
                    // SAME weighting as Content Gap Analysis: 70% title + 30% content
                    const combinedSimilarity = (titleSimilarity * 0.7) + (contentSimilarity * 0.3);
                    
                    // Check for exact title matches (‚â•90% title similarity)
                    if (titleSimilarity >= 0.9) {
                        exactTitleMatch = true;
                    }
                    
                    if (combinedSimilarity > maxCombinedSimilarity) {
                        maxCombinedSimilarity = combinedSimilarity;
                        mostSimilar = item.title || 'Unknown';
                    }
                });
                
                // Use SAME logic as Content Gap Analyzer: 70% threshold
                const isUnique = !exactTitleMatch && maxCombinedSimilarity < 0.70;
                const confidence = exactTitleMatch ? 'duplicate' : 
                                 maxCombinedSimilarity < 0.45 ? 'high' : 
                                 maxCombinedSimilarity < 0.65 ? 'medium' : 'low';
                
                console.log(`üìä REAL VERIFICATION RESULT: ${ideaTitle} - Combined: ${(maxCombinedSimilarity * 100).toFixed(1)}%, Unique: ${isUnique}${exactTitleMatch ? ' (EXACT TITLE MATCH!)' : ''}`);
                
                return {
                    is_unique: isUnique,
                    similarity: maxCombinedSimilarity,
                    most_similar: mostSimilar,
                    confidence: confidence,
                    exact_title_match: exactTitleMatch,
                    method: 'real_verification_same_as_content_gap'
                };
                
            } catch (error) {
                console.error('Error in real similarity verification:', error);
                return { 
                    is_unique: false, 
                    similarity: 0.8, 
                    most_similar: 'verification_failed', 
                    confidence: 'low',
                    method: 'error_fallback'
                };
            }
        }

        // Display the generated unique ideas
        function displayGeneratedIdeas(originalIdea, uniqueIdeas, source) {
            const resultsContainer = document.getElementById('results-container');
            
            if (uniqueIdeas.length === 0) {
                resultsContainer.innerHTML = `
                    <div style="text-align: center; color: #856404; padding: 40px;">
                        <h3>‚ö†Ô∏è No Unique Ideas Found</h3>
                        <p>Could not generate unique alternatives for "${originalIdea}"</p>
                        <p>The topic might be very well covered already, or try a different angle.</p>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div class="statistics">
                    <div class="stat-number">üí°</div>
                    <div class="stat-label">Generated Unique Ideas</div>
                    <p style="margin-top: 10px; color: #8e44ad;">
                        ${uniqueIdeas.length} unique alternatives for: "${originalIdea}"
                    </p>
                </div>

                <div class="gap-card" style="background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border-color: #28a745;">
                    <div class="gap-badge" style="background: #28a745;">üöÄ UNIQUE IDEAS</div>
                    <div class="gap-title">Similar But Unique Content Ideas</div>
                    
                    <div style="margin-top: 20px;">
                        ${uniqueIdeas.map((idea, index) => `
                            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid #28a745; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <strong style="color: #2c3e50; font-size: 1rem;">${idea.title}</strong>
                                    <span style="background: ${idea.uniqueness_verification.confidence === 'duplicate' ? '#dc3545' : '#28a745'}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: bold;">
                                        ${idea.uniqueness_verification.confidence === 'duplicate' ? 'üö´ DUPLICATE' : '‚ú® ' + idea.uniqueness_verification.confidence + ' confidence'}
                                    </span>
                                </div>
                                
                                ${idea.angle ? `
                                    <div style="background: #f8f9fa; padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                                        <strong style="color: #495057; font-size: 0.8rem;">üîç Unique Angle:</strong>
                                        <div style="color: #6c757d; font-size: 0.85rem; margin-top: 4px;">${idea.angle}</div>
                                    </div>
                                ` : ''}
                                
                                ${idea.value_proposition ? `
                                    <div style="background: #e7f3ff; padding: 8px; border-radius: 6px;">
                                        <strong style="color: #0066cc; font-size: 0.8rem;">üí° Value:</strong>
                                        <div style="color: #0066cc; font-size: 0.85rem; margin-top: 4px;">${idea.value_proposition}</div>
                                    </div>
                                ` : ''}
                                
                                <div style="margin-top: 8px; font-size: 0.8rem; color: #666;">
                                    Similarity to existing: ${(idea.uniqueness_verification.similarity * 100).toFixed(1)}%
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; font-size: 0.9rem; color: #28a745;">
                        <strong>üéØ How to use these ideas:</strong><br>
                        ‚Ä¢ Pick the idea that resonates most with your audience<br>
                        ‚Ä¢ These are pre-verified to be unique vs existing ${source} content<br>
                        ‚Ä¢ Each offers a different angle on your original topic<br>
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }

        // Enter key handler for custom idea input
        document.getElementById('custom-idea').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                analyzeCustomIdea();
            }
        });

        // Load saved configuration on page load
        window.addEventListener('load', () => {
            // Load from localStorage if available
            const savedConfig = localStorage.getItem('contentGapConfig');
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    if (config.openaiKey) document.getElementById('openai-key').value = config.openaiKey;
                    if (config.qdrantHost) document.getElementById('qdrant-host').value = config.qdrantHost;
                    if (config.qdrantPort) document.getElementById('qdrant-port').value = config.qdrantPort;
                } catch (e) {
                    console.log('Could not load saved config');
                }
            }
        });

        // Save configuration when changed
        ['openai-key', 'qdrant-host', 'qdrant-port'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                const config = getConfig();
                localStorage.setItem('contentGapConfig', JSON.stringify(config));
            });
        });

        // Similar Ideas Widget Function
        async function generateSimilarUniqueIdeasWidget() {
            const ideaInput = document.getElementById('similar-idea-input');
            const originalIdea = ideaInput.value.trim();
            
            if (!originalIdea) {
                alert('Please enter your draft idea first');
                return;
            }

            const config = getConfig();
            if (!config.openaiKey) {
                alert('Please enter your OpenAI API key in the configuration section');
                return;
            }

            const generateBtn = document.getElementById('generate-ideas-widget-btn');
            const resultsContainer = document.getElementById('similar-ideas-results');
            
            generateBtn.disabled = true;
            generateBtn.textContent = 'üîÑ Generating...';
            resultsContainer.style.display = 'block';
            resultsContainer.innerHTML = `
                <div class="statistics">
                    <div class="stat-number">üîÑ</div>
                    <div class="stat-label">Generating Similar Ideas</div>
                </div>
                <div class="loading">
                    üß† Finding 40 most relevant existing content...<br/>
                    üí° Generating 8 unique variations...<br/>
                    ‚úÖ Verifying uniqueness with embeddings...<br/>
                    ‚è±Ô∏è This may take a moment...
                </div>
            `;

            try {
                console.log('Generating similar unique ideas for:', originalIdea);
                
                // Step 1: Find most relevant existing content for this idea
                const mostRelevantTitles = await findMostRelevantContent(originalIdea, currentSource, config);
                
                // Step 2: Generate 5 similar but unique ideas
                const uniqueIdeas = await generateVerifiedUniqueIdeasWithLinks(originalIdea, mostRelevantTitles, currentSource, config);
                
                // Step 3: CRITICAL: Filter out any ideas that match the original input exactly
                const filteredIdeas = uniqueIdeas.filter(idea => {
                    const similarity = calculateBasicSimilarity(idea.title.toLowerCase(), originalIdea.toLowerCase());
                    const isExactMatch = similarity > 0.9; // 90%+ similarity = too close to original
                    if (isExactMatch) {
                        console.log(`üö´ WIDGET FILTERED OUT: "${idea.title}" - too similar to original input (${(similarity * 100).toFixed(1)}%)`);
                        return false;
                    }
                    return true;
                });
                
                console.log(`‚úÖ Widget filtered results: ${uniqueIdeas.length} ‚Üí ${filteredIdeas.length} unique ideas`);
                
                // Step 4: Display the properly filtered unique ideas in the widget
                displayGeneratedIdeasWidget(originalIdea, filteredIdeas, currentSource);
                
            } catch (error) {
                console.error('Error generating similar unique ideas:', error);
                resultsContainer.innerHTML = `
                    <div class="statistics">
                        <div class="stat-number">‚ùå</div>
                        <div class="stat-label">Generation Failed</div>
                    </div>
                    <div style="text-align: center; color: #dc3545; padding: 40px;">
                        <h3>‚ùå Generation Failed</h3>
                        <p>${error.message}</p>
                        <p>Make sure your API key is correct and try again.</p>
                    </div>
                `;
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'üöÄ Generate Similar Unique Ideas';
            }
        }

        // Generate and verify unique ideas with links to similar content
        async function generateVerifiedUniqueIdeasWithLinks(originalIdea, relevantTitles, source, config, targetCount = 5) {
            const uniqueIdeas = [];
            let attempts = 0;
            const maxAttempts = 3;
            
            // Get full article data with URLs for reference
            const relevantArticles = await findMostRelevantContentWithUrls(originalIdea, source, config);
            
            while (uniqueIdeas.length < targetCount && attempts < maxAttempts) {
                attempts++;
                console.log(`Generation attempt ${attempts}/${maxAttempts}`);
                
                // Generate batch of ideas similar to original
                const generatedIdeas = await generateSimilarIdeasBatch(originalIdea, relevantTitles, source, config.openaiKey);
                
                // Verify each generated idea for uniqueness and find similar articles
                for (const idea of generatedIdeas) {
                    if (uniqueIdeas.length >= targetCount) break;
                    
                    const uniquenessCheck = await verifyIdeaUniquenessWithLinks(idea, relevantArticles, config.openaiKey, 0.7); // Same threshold as Content Gap Analysis
                    
                    if (uniquenessCheck.is_unique) {
                        idea.uniqueness_verification = uniquenessCheck;
                        idea.similar_articles = uniquenessCheck.similar_articles || [];
                        uniqueIdeas.push(idea);
                        console.log(`Found unique idea: ${idea.title}`);
                    } else {
                        const reason = uniquenessCheck.similarity >= 0.9 ? 'EXACT TITLE MATCH' : `${(uniquenessCheck.similarity * 100).toFixed(1)}% combined similarity`;
                        console.log(`‚ùå Rejected similar idea: ${idea.title} (${reason} - too similar to "${uniquenessCheck.most_similar}")`);
                    }
                }
            }
            
            console.log(`üéâ Generated ${uniqueIdeas.length} verified unique ideas with links`);
            return uniqueIdeas;
        }

        // Find most relevant content with URLs
        async function findMostRelevantContentWithUrls(idea, source, config, limit = 40) {
            try {
                const ideaEmbedding = await generateEmbedding(idea, config.openaiKey);
                const collectionName = source.toLowerCase();
                const searchResults = await searchQdrant(
                    ideaEmbedding,
                    collectionName,
                    config.qdrantHost,
                    config.qdrantPort,
                    limit
                );
                
                return searchResults.map(result => ({
                    title: result.payload.title || 'Unknown',
                    url: result.payload.url || '#',
                    content: result.payload.content || '',
                    score: result.score
                }));
                
            } catch (error) {
                console.error('Error finding relevant content with URLs:', error);
                return [];
            }
        }

        // Verify uniqueness using same method as Content Gap Analysis
        async function verifyIdeaUniquenessWithLinks(idea, relevantArticles, apiKey, threshold = 0.7) {
            try {
                // Extract titles for GPT-based similarity analysis (same as Content Gap Analysis)
                const existingTitles = relevantArticles.map(article => article.title);
                
                console.log('üß† Using GPT-4o-mini for title similarity analysis (matching Content Gap method)...');
                
                // Get semantic title similarities from GPT (same function as Content Gap Analysis)
                const titleSimilarities = await calculateTitleSimilarity(idea.title, existingTitles, apiKey);
                
                // Enhance articles with combined similarity scores (70% title, 30% content - same as Content Gap)
                const enhancedArticles = relevantArticles.map((article, index) => {
                    const titleSim = titleSimilarities[index] || 0.3;
                    const contentSim = article.score || 0.5; // Vector search score
                    
                    // Same weighting as Content Gap Analysis: 70% title, 30% content
                    const combinedScore = (titleSim * 0.7) + (contentSim * 0.3);
                    
                    return {
                        ...article,
                        title_similarity: titleSim,
                        content_similarity: contentSim,
                        combined_score: combinedScore,
                        similarity: combinedScore // For display
                    };
                });
                
                // Sort by combined score (same as Content Gap Analysis)
                enhancedArticles.sort((a, b) => b.combined_score - a.combined_score);
                
                const maxCombinedScore = enhancedArticles[0]?.combined_score || 0;
                const mostSimilarArticle = enhancedArticles[0];
                
                // Filter for similar articles to show (combined score > 0.5)
                const similarArticles = enhancedArticles
                    .filter(article => article.combined_score > 0.5)
                    .slice(0, 3)
                    .map(article => ({
                        ...article,
                        similarity: article.combined_score // Use combined score for display
                    }));
                
                // Use same threshold logic as Content Gap Analysis (0.7 = 70%)
                const isUnique = maxCombinedScore < threshold;
                const confidence = maxCombinedScore < 0.45 ? 'high' : maxCombinedScore < 0.65 ? 'medium' : 'low';
                
                console.log(`üìä Uniqueness check: ${idea.title} - Max combined similarity: ${(maxCombinedScore * 100).toFixed(1)}%`);
                
                return {
                    is_unique: isUnique,
                    similarity: maxCombinedScore,
                    most_similar: mostSimilarArticle?.title || '',
                    most_similar_url: mostSimilarArticle?.url || '',
                    confidence: confidence,
                    similar_articles: similarArticles
                };
                
            } catch (error) {
                console.error('Error verifying uniqueness with links:', error);
                return {
                    is_unique: true,
                    similarity: 0,
                    confidence: 'medium',
                    similar_articles: []
                };
            }
        }

        // Display generated ideas in the widget format
        function displayGeneratedIdeasWidget(originalIdea, uniqueIdeas, source) {
            const resultsContainer = document.getElementById('similar-ideas-results');
            
            if (uniqueIdeas.length === 0) {
                resultsContainer.innerHTML = `
                    <div class="statistics">
                        <div class="stat-number">‚ö†Ô∏è</div>
                        <div class="stat-label">No Unique Ideas Found</div>
                    </div>
                    <div style="text-align: center; color: #856404; padding: 40px;">
                        <h3>‚ö†Ô∏è No Unique Ideas Found</h3>
                        <p>Could not generate unique alternatives for "${originalIdea}"</p>
                        <p>The topic might be very well covered already, or try a different angle.</p>
                    </div>
                `;
                return;
            }
            
            let html = `
                <div class="statistics">
                    <div class="stat-number">${uniqueIdeas.length}</div>
                    <div class="stat-label">Unique Ideas Generated</div>
                    <p style="margin-top: 10px; color: #28a745; font-weight: 600;">
                        For: "${originalIdea}"
                    </p>
                </div>

                <div class="gap-card" style="background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%); border-color: #28a745; margin-top: 20px;">
                    <div class="gap-badge" style="background: #28a745;">üí° SIMILAR UNIQUE IDEAS</div>
                    
                    <div style="margin-top: 20px;">
                        ${uniqueIdeas.map((idea, index) => `
                            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid #28a745; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <strong style="color: #2c3e50; font-size: 1rem;">${idea.title}</strong>
                                    <span style="background: ${idea.uniqueness_verification.confidence === 'duplicate' ? '#dc3545' : '#28a745'}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 0.75rem; font-weight: bold;">
                                        ${idea.uniqueness_verification.confidence === 'duplicate' ? 'üö´ DUPLICATE' : '‚ú® ' + idea.uniqueness_verification.confidence + ' unique'}
                                    </span>
                                </div>
                                
                                ${idea.angle ? `
                                    <div style="background: #f8f9fa; padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                                        <strong style="color: #495057; font-size: 0.8rem;">üîç Unique Angle:</strong>
                                        <div style="color: #6c757d; font-size: 0.85rem; margin-top: 4px;">${idea.angle}</div>
                                    </div>
                                ` : ''}
                                
                                ${idea.value_proposition ? `
                                    <div style="background: #e7f3ff; padding: 8px; border-radius: 6px;">
                                        <strong style="color: #0066cc; font-size: 0.8rem;">üí° Value:</strong>
                                        <div style="color: #0066cc; font-size: 0.85rem; margin-top: 4px;">${idea.value_proposition}</div>
                                    </div>
                                ` : ''}
                                
                                <div style="margin-top: 8px; font-size: 0.8rem; color: #666;">
                                    Uniqueness: ${((1 - idea.uniqueness_verification.similarity) * 100).toFixed(1)}%
                                </div>
                                
                                ${idea.similar_articles && idea.similar_articles.length > 0 ? `
                                    <div style="margin-top: 10px; padding: 8px; background: #fff3cd; border-radius: 6px; border-left: 3px solid #ffc107;">
                                        <strong style="color: #856404; font-size: 0.8rem;">üìñ Similar Articles to Differentiate From:</strong>
                                        <div style="margin-top: 4px;">
                                            ${idea.similar_articles.slice(0, 2).map(article => `
                                                <div style="margin-bottom: 4px;">
                                                    <a href="${article.url}" target="_blank" style="color: #856404; font-size: 0.8rem; text-decoration: none;">
                                                        üîó ${article.title}
                                                    </a>
                                                    <span style="color: #6c757d; font-size: 0.75rem; margin-left: 8px;">
                                                        ${(article.similarity * 100).toFixed(1)}% similar
                                                    </span>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: rgba(40, 167, 69, 0.1); border-radius: 6px; font-size: 0.9rem; color: #28a745;">
                        <strong>üéØ Ready to use:</strong> These ideas are pre-verified to be unique vs existing content
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }

        // Enter key handler for similar ideas input
        document.getElementById('similar-idea-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                generateSimilarUniqueIdeasWidget();
            }
        });
    </script>
</body>
</html>
