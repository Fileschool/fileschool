<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>E-E-A-T & Helpful Content Analyzer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/froala-editor@4.6.0/css/froala_editor.pkgd.min.css" rel="stylesheet"
        type="text/css" />
    <style>
        /* Your New Color Palette */
        /* Primary Blue: #0098f7 */
        /* Accent Teal: #15b69b */

        body {
            background-color: #f8f9fa;
            color: #333333;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .header-content {
            max-width: 1280px;
            margin: 20px auto;
            padding: 0 20px;
            width: 100%;
            box-sizing: border-box;
        }

        .main-layout {
            display: flex;
            flex-grow: 1;
            padding: 20px 20px 20px 20px;
            gap: 25px;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            margin: 0;
            height: calc(100vh - 200px);
        }

        .column {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            background: #fff;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
            max-height: 100%;
        }

        .results-column {
            order: 2;
            overflow: hidden;
            position: relative;
        }

        .input-column {
            order: 1;
        }

        h1 {
            color: #005c94;
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 0.5em;
            margin-top: 0;
        }

        h1>i.material-icons {
            color: #0098f7;
            font-size: 1em;
            vertical-align: middle;
        }

        h2 {
            color: #0077c2;
            text-align: center;
            margin-top: 0;
            margin-bottom: 1em;
            font-size: 1.8rem;
        }

        .requirements {
            background: #e6f5ff;
            border-left: 4px solid #0098f7;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .requirements ul,
        .requirements ol {
            margin-top: 10px;
            padding-left: 25px;
        }

        .requirements strong {
            font-size: 1.1em;
            color: #005c94;
        }

        /* Navigation Sidebar Styles */
        .results-wrapper {
            display: flex;
            height: 100%;
            gap: 20px;
        }

        .results-nav {
            width: 280px;
            min-width: 280px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
            position: sticky;
            top: 20px;
            align-self: flex-start;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .results-nav h3 {
            font-size: 1.1rem;
            color: #005c94;
            margin: 0 0 20px 0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        .nav-section {
            margin-bottom: 20px;
        }

        .nav-section h4 {
            font-size: 0.9rem;
            color: #0077c2;
            margin: 0 0 8px 0;
            font-weight: 500;
        }

        .nav-links {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .nav-links li {
            margin-bottom: 10px;
        }

        .nav-links a {
            color: #555;
            text-decoration: none;
            font-size: 0.95rem;
            padding: 10px 16px;
            border-radius: 6px;
            display: block;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
            line-height: 1.4;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .nav-links a:hover {
            background: #e6f5ff;
            color: #0098f7;
            border-left-color: #0098f7;
            transform: translateX(2px);
        }

        .nav-links a.active {
            background: #0098f7;
            color: white;
            border-left-color: #005c94;
            font-weight: 500;
        }

        .nav-links a .score {
            font-weight: 600;
            font-size: 0.85rem;
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
            margin-left: 8px;
        }

        .nav-links a.active .score {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Results Content Area */
        .results-content {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        #resultsArea {
            padding: 30px;
            background: #ffffff;
            min-height: 400px;
            line-height: 1.8;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        /* Enhanced Results Formatting */
        #resultsArea>h2:first-child {
            margin-top: 0;
        }

        #resultsArea h2 {
            font-size: 1.8rem;
            color: #15b69b;
            margin: 3em 0 1.5em 0;
            padding-bottom: 12px;
            border-bottom: 3px solid #15b69b;
            position: relative;
        }

        #resultsArea h2:before {
            content: '';
            position: absolute;
            left: 0;
            bottom: -3px;
            width: 60px;
            height: 3px;
            background: #0098f7;
        }

        #resultsArea h3 {
            font-size: 1.4rem;
            color: #13a38a;
            margin: 2em 0 1em 0;
            font-weight: 600;
        }

        #resultsArea h4 {
            font-size: 1.2rem;
            color: #0f8b75;
            margin: 1.5em 0 0.8em 0;
            font-weight: 500;
        }

        #resultsArea strong {
            color: #0077c2;
            font-weight: 600;
        }

        #resultsArea ul,
        #resultsArea ol {
            margin: 1.5em 0;
            padding-left: 2em;
        }

        #resultsArea li {
            margin: 0.8em 0;
            line-height: 1.8;
        }

        #resultsArea p {
            margin: 1.2em 0;
            line-height: 1.8;
            color: #444;
        }

        /* Score and Priority Styling */
        #resultsArea p:has(strong:contains("Score:")) {
            background: #f0f9ff;
            padding: 12px 16px;
            border-radius: 6px;
            margin: 1.5em 0;
            border-left: 4px solid #0098f7;
            font-size: 1.1rem;
        }

        #resultsArea p:has(strong:contains("Priority:")) {
            background: #e8f5f2;
            padding: 10px 14px;
            border-radius: 6px;
            margin: 1em 0;
            border-left: 4px solid #15b69b;
        }

        /* Enhanced Warning Note Styling */
        .warning-note {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%) !important;
            padding: 16px 20px 16px 50px !important;
            border-radius: 8px !important;
            margin: 2em 0 !important;
            border: 2px solid #f39c12 !important;
            border-left: 6px solid #e67e22 !important;
            font-style: italic !important;
            color: #8b4513 !important;
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.15) !important;
            position: relative !important;
        }
        
        .warning-note::before {
            content: "⚠️";
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.4em;
            background: #f39c12;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        .warning-note strong {
            color: #d68910 !important;
            font-weight: 700 !important;
        }

        /* Optimized Skeleton Loading Animation */
        .skeleton-loading {
            padding: 20px;
        }

        .skeleton-loading.active {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .skeleton-line {
            height: 20px;
            background: #f0f0f0;
            border-radius: 4px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }

        .skeleton-line.animated::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        .skeleton-line.short {
            width: 60%;
        }

        .skeleton-line.medium {
            width: 80%;
        }

        .skeleton-line.long {
            width: 95%;
        }

        .skeleton-title {
            height: 30px;
            width: 70%;
            background: #15b69b;
            border-radius: 6px;
            margin: 20px 0 15px 0;
            position: relative;
            overflow: hidden;
        }

        .skeleton-title.animated::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        .analyzing-text {
            text-align: center;
            font-size: 1.2em;
            color: #0098f7;
            margin: 20px 0;
            font-weight: 500;
        }

        .error-message {
            color: #d32f2f;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #d32f2f;
        }

        table#scoreTable {
            width: 100%;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        table.striped.blue-theme-table {
            border: none;
        }

        table.striped.blue-theme-table thead tr {
            background: #0098f7;
            color: white;
        }

        table.striped.blue-theme-table thead th {
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-size: 0.9rem;
            padding: 14px 16px;
            border: none;
        }

        table.striped.blue-theme-table tr td,
        table.striped.blue-theme-table tr th {
            color: #00304A;
            padding: 12px 16px;
        }

        table.striped.blue-theme-table tbody tr:nth-child(odd) {
            background-color: #f8fbff;
        }

        table.striped.blue-theme-table tbody tr:hover {
            background-color: #e6f5ff;
            transition: background-color 0.2s ease;
        }

        .status-text {
            margin-top: 10px;
            font-style: italic;
            color: #555;
            text-align: center;
            height: 1.5em;
        }

        #editor {
            border: 1px solid #b3e0ff;
            margin-top: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .editor-controls-wrapper {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }

        .froala-wrapper {
            border: none !important;
            display: flex;
            flex-direction: column;
        }

        .froala-wrapper .fr-element {
            flex-grow: 1;
            overflow-y: auto;
            min-height: 50px;
        }

        .overall-score td {
            font-weight: bold;
            background-color: #0098f7 !important;
            color: white !important;
            font-size: 1.1rem;
        }

        .progress {
            background-color: #b3e0ff;
            margin-top: 15px;
        }

        .progress .determinate {
            background-color: #0098f7 !important;
        }

        .input-field {
            margin-bottom: 1rem;
        }

        .input-field input[type=text]:focus+label,
        .input-field input[type=password]:focus+label {
            color: #0098f7 !important;
        }

        .input-field input[type=text]:focus,
        .input-field input[type=password]:focus {
            border-bottom: 1px solid #0098f7 !important;
            box-shadow: 0 1px 0 0 #0098f7 !important;
        }

        .controls-area {
            margin-top: 20px;
        }

        #analyzeButton.btn-large.blue.darken-2,
        .btn-large.custom-blue-button {
            background-color: #0098f7 !important;
            color: #fff !important;
        }

        #analyzeButton.btn-large.blue.darken-2:hover,
        .btn-large.custom-blue-button:hover {
            background-color: #007acc !important;
        }

        /* Tab styling */
        .tabs .tab a {
            color: #00B093;
        }

        .tabs .tab a:hover {
            color: #00B093;
            background-color: rgba(0, 176, 147, 0.1);
        }

        .tabs .indicator {
            background-color: #00B093;
        }

        .tabs .tab a.active {
            color: #00B093;
            background-color: transparent;
        }

        .tabs .tab a:focus,
        .tabs .tab a:focus.active {
            background-color: transparent;
        }

        /* Chunkability Results Styling - Match Content Analysis */
        #chunkabilityResults {
            padding: 30px;
            background: #ffffff;
            min-height: 400px;
            line-height: 1.8;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        #chunkabilityResults>h2:first-child {
            margin-top: 0;
        }

        #chunkabilityResults h2 {
            font-size: 1.8rem;
            color: #15b69b;
            margin: 3em 0 1.5em 0;
            padding-bottom: 12px;
            border-bottom: 3px solid #15b69b;
            position: relative;
        }

        #chunkabilityResults h2:before {
            content: '';
            position: absolute;
            left: 0;
            bottom: -3px;
            width: 60px;
            height: 3px;
            background: #0098f7;
        }

        #chunkabilityResults h3 {
            font-size: 1.4rem;
            color: #13a38a;
            margin: 2em 0 1em 0;
            font-weight: 600;
        }

        #chunkabilityResults h4 {
            font-size: 1.2rem;
            color: #0f8b75;
            margin: 1.5em 0 0.8em 0;
            font-weight: 500;
        }

        #chunkabilityResults h5,
        #chunkabilityResults h6 {
            font-size: 1.1rem;
            color: #0c7a68;
            margin: 1.2em 0 0.6em 0;
            font-weight: 500;
        }

        #chunkabilityResults p {
            margin: 1.2em 0;
            line-height: 1.8;
            color: #444;
        }

        #chunkabilityResults ul,
        #chunkabilityResults ol {
            margin: 1.5em 0;
            padding-left: 2em;
        }

        #chunkabilityResults li {
            margin: 0.8em 0;
            line-height: 1.8;
        }

        #chunkabilityResults strong {
            color: #0077c2;
            font-weight: 600;
        }

        /* Score and Priority Styling for Chunkability */
        #chunkabilityResults p:has(strong:contains("Score:")) {
            background: #f0f9ff;
            padding: 12px 16px;
            border-radius: 6px;
            margin: 1.5em 0;
            border-left: 4px solid #0098f7;
            font-size: 1.1rem;
        }

        #chunkabilityResults p:has(strong:contains("Priority:")) {
            background: #e8f5f2;
            padding: 10px 14px;
            border-radius: 6px;
            margin: 1em 0;
            border-left: 4px solid #15b69b;
        }


        #chunkabilityResults .criteria {
            background: #f0f9ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #15b69b;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #chunkabilityResults .yes {
            color: #2e7d32;
            font-weight: 600;
            background: #e8f5e9;
            padding: 2px 6px;
            border-radius: 4px;
        }

        #chunkabilityResults .no {
            color: #c62828;
            font-weight: 600;
            background: #ffebee;
            padding: 2px 6px;
            border-radius: 4px;
        }

        #chunkabilityResults .rating {
            font-weight: bold;
            color: #00B093;
            font-size: 1.3em;
            background: #e6f7f4;
            padding: 10px 16px;
            border-radius: 6px;
            display: inline-block;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #chunkabilityResults blockquote {
            border-left: 4px solid #15b69b;
            background: #f8fcff;
            padding: 20px 24px;
            margin: 24px 0;
            font-style: italic;
            color: #555;
            border-radius: 0 8px 8px 0;
        }

        #chunkabilityResults code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            color: #d63384;
            font-family: 'Courier New', monospace;
        }

        #chunkabilityResults pre {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            overflow-x: auto;
            margin: 20px 0;
        }

        .tab-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Ensure both tab contents have identical layout */
        #contentAnalysisTab,
        #chunkabilityTab {
            width: 100%;
            height: 100%;
        }

        #contentAnalysisTab .results-wrapper,
        #chunkabilityTab .results-wrapper {
            width: 100%;
            height: 100%;
        }

        /* Hide navigation on initial load */
        .results-nav:not(.has-results) {
            display: none;
        }

        /* Smooth scroll behavior */
        html {
            scroll-behavior: smooth;
        }

        @media (max-width: 992px) {
            .main-layout {
                flex-direction: column;
                padding: 10px 10px 10px 10px;
                gap: 15px;
                height: auto;
            }

            .column {
                flex-basis: auto;
                width: 100%;
                max-height: none;
            }

            .results-column {
                order: 2;
            }

            .input-column {
                order: 1;
            }

            .results-wrapper {
                flex-direction: column;
            }

            .results-nav {
                width: 100%;
                max-height: 300px;
                margin-bottom: 20px;
                position: relative;
                top: auto;
            }

            #resultsArea,
            #chunkabilityResults {
                min-height: 250px;
                max-height: 400px;
            }
        }
    </style>
</head>

<body>

    <div class="main-layout">
        <div class="column input-column">
            <h2>Input Content & Analyze</h2>
            <div class="input-field">
                <input id="apiKey" type="password">
                <label for="apiKey">DeepSeek API Key *</label>
            </div>
            <p style="margin-top: -0.5rem; margin-bottom: 1.5rem; font-size: 0.9em; color: #555;">Optional Metadata:</p>
            <div class="input-field">
                <input id="metaTitle" type="text" placeholder="Complete Guide to Digital Marketing Strategies in 2024">
                <label for="metaTitle">Title Tag (Optional)</label>
            </div>
            <div class="input-field">
                <input id="metaDescription" type="text"
                    placeholder="Discover proven digital marketing strategies and tactics that will boost your online presence and drive more conversions in 2024.">
                <label for="metaDescription">Meta Description (Optional)</label>
            </div>
            <div class="input-field">
                <input id="metaSlug" type="text" placeholder="complete-guide-digital-marketing-strategies-2024">
                <label for="metaSlug">URL Slug (Optional)</label>
            </div>
            <label style="font-size: 0.9em; color: #555; display: block; margin-bottom: -10px;">Article Content
                *:</label>
            <div class="editor-controls-wrapper" style="display: flex; flex-direction: column; flex-grow: 1;">
                <div id="editor" style="flex-grow: 1; display: flex; flex-direction: column;"></div>
                <div class="controls-area">
                    <div class="center-align">
                        <button id="analyzeButton" class="btn-large blue darken-2 waves-effect waves-light">
                            <i class="material-icons left">play_arrow</i>Analyze & Check Chunkability
                        </button>
                    </div>
                    <div class="progress" style="margin-top:25px; display:none;">
                        <div class="determinate green darken-1" id="progressBar" style="width: 0%"></div>
                    </div>
                    <div id="errorMessage" class="error-message" style="display: none;"></div>
                    <div class="status-text" id="statusText"></div>
                </div>
            </div>
        </div>
        <div class="column results-column">
            <h2>Analysis Results</h2>
            <table id="scoreTable" class="striped blue-theme-table responsive-table" style="display:none;">
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Score</th>
                    </tr>
                </thead>
                <tbody id="scoreTableBody"></tbody>
            </table>
            <div class="tabs-container">
                <ul class="tabs">
                    <li class="tab col s6"><a class="active" href="#contentAnalysisTab">Content Analysis</a></li>
                    <li class="tab col s6"><a href="#chunkabilityTab">Chunkability</a></li>
                </ul>
            </div>
            <div id="contentAnalysisTab" class="tab-content">
                <div class="results-wrapper">
                    <nav class="results-nav" id="contentNav">
                        <h3>Quick Navigation</h3>
                        <ul class="nav-links" id="contentNavLinks">
                            <!-- Navigation links will be dynamically generated here -->
                        </ul>
                    </nav>
                    <div class="results-content">
                        <div id="resultsArea">
                            <div class="analyzing-text">
                                <i class="material-icons"
                                    style="vertical-align: middle; margin-right: 8px;">assessment</i>
                                Ready to analyze your content
                            </div>
                            <p style="text-align: center; color: #666; margin-top: 20px;">
                                Paste your content and click "Analyze" to get detailed E-E-A-T feedback and
                                recommendations.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <div id="chunkabilityTab" class="tab-content">
                <div class="results-wrapper">
                    <nav class="results-nav" id="chunkNav">
                        <h3>Quick Navigation</h3>
                        <ul class="nav-links" id="chunkNavLinks">
                            <!-- Navigation links will be dynamically generated here -->
                        </ul>
                    </nav>
                    <div class="results-content">
                        <div id="chunkabilityResults">
                            <div class="analyzing-text">
                                <i class="material-icons"
                                    style="vertical-align: middle; margin-right: 8px;">view_module</i>
                                Ready to check chunkability
                            </div>
                            <p style="text-align: center; color: #666; margin-top: 20px;">
                                Chunkability analysis will assess how well your content can be processed by AI systems.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-content">
        <h1><i class="material-icons" style="vertical-align: middle; font-size: 1.2em;">assessment</i> E-E-A-T & Helpful
            Content Analyzer</h1>
        <div class="requirements">
            <strong>Analysis Criteria (based on Google's E-E-A-T & Helpful Content):</strong>
            <ul>
                <li><strong>Content Quality & Depth</strong>: Assess detail, completeness, and evidence of first-hand
                    experience.</li>
                <li><strong>Expertise & Credibility</strong>: Look for author credentials, cited sources, and expert
                    quotes.</li>
                <li><strong>Engagement & Presentation</strong>: Evaluate readability, structure (headings, lists),
                    visuals, and calls-to-action.</li>
                <li><strong>Originality & Insight</strong>: Identify unique perspectives, data, or analysis beyond
                    common knowledge.</li>
                <li><strong>Trustworthiness & Transparency</strong>: Check for clear authorship, contact info,
                    disclosures, and methodology explanation.</li>
                <li><strong>Metadata Relevance (Optional)</strong>: Assess alignment of title, description, and URL with
                    content focus (if provided).</li>
            </ul>
            <p><strong>Important Note:</strong> <em>Due to API limitations, this analysis focuses exclusively on textual
                    content. Images, graphics, and visual elements are automatically excluded from all scoring and
                    recommendations.</em></p>
            <p><strong>Feedback Format:</strong></p>
            <ol>
                <li>Clear identification of the issue or strength.</li>
                <li>Specific, actionable recommendations for improvement.</li>
                <li>Concrete examples where applicable (e.g., suggested phrasings, section ideas).</li>
                <li>A 1-10 score for each category and a High/Medium/Low priority for fixes.</li>
            </ol>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/froala-editor@4.6.0/js/froala_editor.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            M.AutoInit();
            M.updateTextFields();
            
            // Initialize tabs specifically
            const tabsElement = document.querySelector('.tabs');
            if (tabsElement) {
                M.Tabs.init(tabsElement);
            }
            try {
                new FroalaEditor('#editor', {
                    placeholderText: 'Paste your article HTML or text content here...',
                    heightMin: 150, heightMax: 400,
                    toolbarButtons: ['bold', 'italic', 'underline', 'strikeThrough', '|', 'align', 'formatOL', 'formatUL', 'outdent', 'indent', '|', 'insertLink', 'insertImage', 'insertTable', '|', 'undo', 'redo', 'clearFormatting', 'html'],
                    height: '100%'
                });
            } catch (e) {
                console.error("Froala Editor initialization failed:", e);
                document.getElementById('editor').innerText = "Failed to load rich text editor. Please paste plain text.";
            }
            if (window.marked) {
                marked.setOptions({ breaks: true, gfm: true, headerIds: false, mangle: false });
            }
        });

        const apiKeyInput = document.getElementById('apiKey');
        const metaTitleInput = document.getElementById('metaTitle');
        const metaDescriptionInput = document.getElementById('metaDescription');
        const metaSlugInput = document.getElementById('metaSlug');
        const analyzeButton = document.getElementById('analyzeButton');
        const resultsArea = document.getElementById('resultsArea');
        const errorMessageDiv = document.getElementById('errorMessage');
        const scoreTable = document.getElementById('scoreTable');
        const scoreTableBody = document.getElementById('scoreTableBody');
        const progressBar = document.getElementById('progressBar');
        const progressContainer = document.querySelector('.progress');
        const statusText = document.getElementById('statusText');

        const apiUrl = 'https://api.deepseek.com/chat/completions';
        const modelName = 'deepseek-chat';

        // Navigation elements
        const contentNav = document.getElementById('contentNav');
        const contentNavLinks = document.getElementById('contentNavLinks');
        const chunkNav = document.getElementById('chunkNav');
        const chunkNavLinks = document.getElementById('chunkNavLinks');

        // --- NEW: Loading messages and interval ID ---
        let loadingIntervalId = null;
        const loadingMessages = [
            "Analyzing content structure...",
            "Evaluating E-E-A-T signals...",
            "Processing expertise indicators...",
            "Checking trustworthiness factors...",
            "Assessing content depth...",
            "Analyzing engagement elements...",
            "Reviewing originality markers...",
            "Examining authoritativeness...",
            "Evaluating user experience...",
            "Processing content quality...",
            "Analyzing readability patterns...",
            "Checking source credibility...",
            "Assessing content completeness...",
            "Reviewing metadata alignment...",
            "Analyzing chunkability factors...",
            "Processing final recommendations..."
        ];

        // Optimized navigation generation with special handling for chunkability
        function generateNavigation(content, navContainer, prefix = '') {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const headings = tempDiv.querySelectorAll('h2, h3');
            const navItems = [];
            const fragment = document.createDocumentFragment();
            
            // Check if this is chunkability content
            const isChunkability = prefix === 'chunk';

            headings.forEach((heading, index) => {
                const text = heading.textContent;
                const id = `${prefix}heading-${index}`;
                heading.id = id;

                // Extract score if present (optimize regex)
                let scoreText = '';
                const nextEl = heading.nextElementSibling;
                if (nextEl) {
                    const scoreMatch = nextEl.textContent?.match(/Score:\s*(\d+)\/10/);
                    if (scoreMatch) {
                        scoreText = `<span class="score">${scoreMatch[1]}/10</span>`;
                    }
                }

                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = `#${id}`;
                a.className = 'nav-link';
                a.innerHTML = `${text}${scoreText}`;
                
                // Special handling for chunkability navigation
                if (isChunkability) {
                    // Skip the main "Chunkability Analysis" header
                    if (text.toLowerCase().includes('chunkability analysis')) {
                        return; // Skip this heading
                    }
                    
                    // Treat numbered items (like "1. Heading Alignment Assessment") as main items (H2 style)
                    // and everything else as sub-items (H3 style)
                    const isNumberedItem = /^\d+\.\s/.test(text);
                    
                    if (!isNumberedItem && heading.tagName === 'H3') {
                        li.style.paddingLeft = '20px';
                        a.style.fontSize = '0.825rem';
                    }
                } else {
                    // Standard content analysis handling
                    if (heading.tagName === 'H3') {
                        li.style.paddingLeft = '20px';
                        a.style.fontSize = '0.825rem';
                    }
                }
                
                li.appendChild(a);
                fragment.appendChild(li);
                navItems.push({ link: a, targetId: id });
            });

            navContainer.innerHTML = '';
            navContainer.appendChild(fragment);

            // Use event delegation for better performance
            navContainer.addEventListener('click', (e) => {
                const link = e.target.closest('.nav-link');
                if (link) {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Update active state efficiently
                        const activeLink = navContainer.querySelector('.nav-link.active');
                        if (activeLink) activeLink.classList.remove('active');
                        link.classList.add('active');
                    }
                }
            });

            return tempDiv.innerHTML;
        }

        // Function to apply warning styling to notes
        function applyWarningNoteStyling(container) {
            const paragraphs = container.querySelectorAll('p');
            let notesFound = 0;
            
            paragraphs.forEach(p => {
                const strongElements = p.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    if (strong.textContent.includes('Note:')) {
                        p.classList.add('warning-note');
                        notesFound++;
                        console.log('Applied warning-note styling to:', p.textContent.substring(0, 100) + '...');
                    }
                });
                
                // Also check if the paragraph itself contains "Note:" even without strong tags
                if (p.textContent.includes('Note:') && p.textContent.includes('analysis focuses exclusively')) {
                    p.classList.add('warning-note');
                    notesFound++;
                    console.log('Applied warning-note styling to note paragraph:', p.textContent.substring(0, 100) + '...');
                }
            });
            
            console.log(`Applied warning styling to ${notesFound} notes in`, container.id || 'container');
        }

        // Optimized skeleton loading animation
        function createSkeletonLoading() {
            return `
                <div class="skeleton-loading active">
                    <div class="analyzing-text">
                        <i class="material-icons" style="vertical-align: middle; margin-right: 8px;">sync</i>
                        Analyzing your content...
                    </div>
                    <div class="skeleton-title animated"></div>
                    <div class="skeleton-line long animated"></div>
                    <div class="skeleton-line medium animated"></div>
                    <div class="skeleton-line short animated"></div>
                    <div class="skeleton-line long animated"></div>
                    
                    <div class="skeleton-title animated" style="margin-top: 30px;"></div>
                    <div class="skeleton-line medium animated"></div>
                    <div class="skeleton-line long animated"></div>
                    <div class="skeleton-line short animated"></div>
                    <div class="skeleton-line medium animated"></div>
                    
                    <div class="skeleton-title animated" style="margin-top: 30px;"></div>
                    <div class="skeleton-line long animated"></div>
                    <div class="skeleton-line short animated"></div>
                    <div class="skeleton-line medium animated"></div>
                </div>
            `;
        }

        function createChunkabilitySkeletonLoading() {
            return `
                <div class="skeleton-loading active">
                    <div class="analyzing-text">
                        <i class="material-icons" style="vertical-align: middle; margin-right: 8px;">view_module</i>
                        Analyzing chunkability...
                    </div>
                    <div class="skeleton-title animated"></div>
                    <div class="skeleton-line long animated"></div>
                    <div class="skeleton-line medium animated"></div>
                    
                    <div class="skeleton-title animated" style="margin-top: 25px;"></div>
                    <div class="skeleton-line short animated"></div>
                    <div class="skeleton-line long animated"></div>
                    
                    <div class="skeleton-title animated" style="margin-top: 25px;"></div>
                    <div class="skeleton-line medium animated"></div>
                    <div class="skeleton-line short animated"></div>
                </div>
            `;
        }

        analyzeButton.addEventListener('click', async () => {
            // Initialize tabs properly
            const tabsElement = document.querySelector('.tabs');
            if (!M.Tabs.getInstance(tabsElement)) {
                M.Tabs.init(tabsElement);
            }

            // Run combined analysis
            await handleCombinedAnalysis();
        });

        function moveProgress(percent) { progressBar.style.width = percent + '%'; }

        async function fakeProgress(startPercent, endPercent, duration) {
            const steps = 5; // Reduced steps for better performance
            const increment = (endPercent - startPercent) / steps;
            const delay = duration / steps;
            let currentPercent = startPercent;
            
            for (let i = 0; i < steps; i++) {
                await sleep(delay);
                currentPercent += increment;
                moveProgress(Math.min(currentPercent, endPercent));
            }
            moveProgress(endPercent);
        }

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        function showError(message) {
            // --- NEW: Clear loading interval on error ---
            if (loadingIntervalId) {
                clearInterval(loadingIntervalId);
                loadingIntervalId = null;
            }
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            progressContainer.style.display = 'none';
            statusText.textContent = '';
            // --- NEW: Update resultsArea to indicate failure ---
            resultsArea.innerHTML = `<p style="text-align:center; color:red; font-weight:bold;">Analysis failed.</p><p style="text-align:center;">Please check the error message above or in the console.</p>`;
            document.getElementById('chunkabilityResults').innerHTML = `<p style="text-align:center; color:red; font-weight:bold;">Analysis failed.</p>`;

            // Hide navigation on error
            contentNav.classList.remove('has-results');
            chunkNav.classList.remove('has-results');
        }

        function resetState(statusMsg = '') {
            analyzeButton.disabled = false;
            analyzeButton.innerHTML = '<i class="material-icons left">play_arrow</i>Analyze & Check Chunkability';
            if (errorMessageDiv.style.display === 'none' && statusText.textContent !== 'Analysis complete!') {
                statusText.textContent = statusMsg;
            }
            if (document.title === 'Analyzing...') {
                document.title = 'E-E-A-T & Helpful Content Analyzer';
            }
        }

        function displayResults(markdown) {
            let totalScore = 0;
            let scoreCount = 0;
            
            // Clear containers efficiently
            scoreTableBody.textContent = '';
            resultsArea.textContent = '';

            // Optimize regex processing - split into lines first
            const lines = markdown.split('\n');
            const sections = [];
            let currentSection = null;
            let currentContent = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('##') || line.startsWith('###') || line.startsWith('####')) {
                    // Save previous section
                    if (currentSection) {
                        sections.push({
                            title: currentSection,
                            content: currentContent.join('\n')
                        });
                    }
                    // Start new section
                    currentSection = line.replace(/^#+\s*/, '').trim();
                    currentContent = [];
                } else {
                    currentContent.push(line);
                }
            }
            
            // Don't forget the last section
            if (currentSection) {
                sections.push({
                    title: currentSection,
                    content: currentContent.join('\n')
                });
            }

            // Process sections more efficiently
            const scorePattern = /\*\*Score:\s*(\d{1,2})\/10\*\*/;
            const excludeCategories = ['overall summary', 'content analysis summary', 'chunkability analysis'];
            
            sections.forEach(section => {
                const category = section.title.toLowerCase();
                if (excludeCategories.some(exc => category.includes(exc))) return;

                const scoreMatch = section.content.match(scorePattern);
                if (scoreMatch) {
                    const score = parseInt(scoreMatch[1], 10);
                    if (!isNaN(score)) {
                        const row = document.createElement('tr');
                        const categoryCell = document.createElement('td');
                        const scoreCell = document.createElement('td');
                        categoryCell.textContent = section.title;
                        scoreCell.textContent = `${score}/10`;
                        row.appendChild(categoryCell);
                        row.appendChild(scoreCell);
                        scoreTableBody.appendChild(row);
                        totalScore += score;
                        scoreCount++;
                    }
                }
            });

            // Add overall score
            if (scoreCount > 0) {
                const overallScore = (totalScore / scoreCount).toFixed(1);
                const overallRow = document.createElement('tr');
                overallRow.classList.add('overall-score');
                const categoryCell = document.createElement('td');
                const scoreCell = document.createElement('td');
                categoryCell.innerHTML = '<strong>Overall Score</strong>';
                scoreCell.innerHTML = `<strong>${overallScore}/10</strong>`;
                overallRow.appendChild(categoryCell);
                overallRow.appendChild(scoreCell);
                scoreTableBody.appendChild(overallRow);
                scoreTable.style.display = 'table';
            } else {
                scoreTable.style.display = 'none';
                resultsArea.innerHTML = "<p><em>Could not extract scores from the analysis. Displaying raw response below.</em></p><hr>";
            }

            // Render markdown more efficiently
            if (window.marked && marked.parse) {
                requestAnimationFrame(() => {
                    const htmlContent = marked.parse(markdown);
                    const processedContent = generateNavigation(htmlContent, contentNavLinks, 'content');
                    resultsArea.innerHTML = processedContent;
                    
                    // Apply warning styling to notes (with delay to ensure DOM is ready)
                    setTimeout(() => {
                        applyWarningNoteStyling(resultsArea);
                    }, 100);
                    
                    contentNav.classList.add('has-results');
                });
            } else {
                resultsArea.innerHTML = `<pre>${markdown}</pre>`;
                applyWarningNoteStyling(resultsArea);
            }
        }

        async function handleCombinedAnalysis() {
            document.title = 'Analyzing...';
            const apiKey = apiKeyInput.value.trim();
            const metaTitle = metaTitleInput.value.trim();
            const metaDescription = metaDescriptionInput.value.trim();
            const metaSlug = metaSlugInput.value.trim();
            let content = '';

            if (typeof FroalaEditor !== 'undefined' && FroalaEditor.INSTANCES && FroalaEditor.INSTANCES[0]) {
                content = FroalaEditor.INSTANCES[0].html.get();
            } else {
                const editorDiv = document.getElementById('editor');
                content = editorDiv.innerText || editorDiv.innerHTML;
            }

            // Clear previous results and show loading states
            errorMessageDiv.textContent = '';
            errorMessageDiv.style.display = 'none';
            scoreTable.style.display = 'none';
            scoreTableBody.innerHTML = '';
            statusText.textContent = '';
            progressBar.style.width = '0%';
            progressContainer.style.display = 'block';
            analyzeButton.disabled = true;
            analyzeButton.innerHTML = '<i class="material-icons left">hourglass_top</i>Analyzing...';

            // Hide navigation initially
            contentNav.classList.remove('has-results');
            chunkNav.classList.remove('has-results');

            // Show skeleton loading in both tabs
            resultsArea.innerHTML = createSkeletonLoading();
            document.getElementById('chunkabilityResults').innerHTML = createChunkabilitySkeletonLoading();

            // Start cycling through loading messages (optimized)
            let messageIndex = 0;
            if (loadingIntervalId) {
                clearInterval(loadingIntervalId);
            }
            loadingIntervalId = setInterval(() => {
                const skeletonText = resultsArea.querySelector('.analyzing-text');
                const chunkabilityText = document.getElementById('chunkabilityResults').querySelector('.analyzing-text');
                if (skeletonText && chunkabilityText) {
                    const iconElement = skeletonText.querySelector('.material-icons');
                    const message = loadingMessages[messageIndex];
                    if (iconElement && iconElement.nextSibling) {
                        iconElement.nextSibling.textContent = message;
                    } else {
                        skeletonText.innerHTML = `<i class="material-icons" style="vertical-align: middle; margin-right: 8px;">sync</i>${message}`;
                    }
                    messageIndex = (messageIndex + 1) % loadingMessages.length;
                }
            }, 3000);

            statusText.textContent = 'Step 1/7: Validating inputs...';
            moveProgress(5);

            if (!apiKey) {
                showError('API Key is required.');
                resetState('Please enter your DeepSeek API Key.');
                return;
            }
            if (!content || content.trim().length < 100) {
                showError('Article content is required (minimum 100 characters).');
                resetState('Please paste sufficient content into the editor.');
                return;
            }

            try {
                statusText.textContent = 'Step 2/7: Preparing combined analysis prompt...';
                moveProgress(15);

                const prompt = `You are an expert content analyst specializing in Google's E-E-A-T (Experience, Expertise, Authoritativeness, Trustworthiness) and Helpful Content guidelines. Please provide a comprehensive analysis with clear section headers.

**CRITICAL INSTRUCTION: EXCLUDE ALL IMAGES FROM ANALYSIS**
- Do NOT evaluate, score, or comment on any images, graphics, visual elements, or image tags
- Focus EXCLUSIVELY on textual content, structure, and written information
- Do NOT penalize content for missing images or broken image links
- Image-related elements should be completely ignored in all scoring categories

**IMPORTANT: Use these EXACT section headers:**
## Content Quality & Depth
## Expertise & Credibility  
## Engagement & Presentation
## Originality & Insight
## Trustworthiness & Transparency
${metaTitle || metaDescription || metaSlug ? '## Metadata Relevance' : ''}
## Content Analysis Summary
## Chunkability Analysis

For each E-E-A-T category (Content Quality through ${metaTitle || metaDescription || metaSlug ? 'Metadata Relevance' : 'Trustworthiness & Transparency'}):
- Assess strengths and weaknesses (TEXT ONLY - ignore all visual elements)
- Provide specific, actionable recommendations for textual improvements
- Use bullet points and clear formatting for recommendations
- Include: **Score: [X]/10** (based solely on textual content)
- Include: **Priority: [High/Medium/Low]**
- End with: **Note: This analysis focuses exclusively on textual content and excludes all visual elements due to API limitations.**

For Content Analysis Summary:
- Provide a comprehensive overview of the main findings
- List the top 3-5 most critical improvements needed using bullet points
- Prioritize recommendations by impact (High/Medium/Low priority items)
- Include an action plan with specific next steps in a numbered list
- Mention the overall content strengths to build upon
- End with: **Note: This analysis focuses exclusively on textual content and excludes all visual elements due to API limitations.**

For Chunkability Analysis, evaluate TEXT-BASED elements only with PROPER SPACING:

### 1. Heading Alignment Assessment
**Status:** ✅/❌ - Do text headings clearly organize topics?
**Details:** [Detailed explanation with line breaks]

### 2. Entity Coverage Assessment  
**Status:** ✅/❌ - Are key entities/concepts well-defined in text?
**Details:** [Detailed explanation with line breaks]

### 3. Topical Focus Assessment
**Status:** ✅/❌ - Does each text section stay on topic?
**Details:** [Detailed explanation with line breaks]

### 4. LLM Retrievability Assessment
**Status:** ✅/❌ - Can AI easily extract information from text?
**Details:** [Detailed explanation with line breaks]

### 5. Overall Chunkability Rating
**Rating:** [X]/10 (text-based assessment only)
**Justification:** [Detailed explanation]

### 6. Specific Chunkability Recommendations
- **High Priority:** [List items with explanations using bullet points]
- **Medium Priority:** [List items with explanations using bullet points]  
- **Low Priority:** [List items with explanations using bullet points]

**Note: This analysis focuses exclusively on textual content and excludes all visual elements due to API limitations.**

--- CONTENT TO ANALYZE ---
${content}
${metaTitle ? '\nTitle: ' + metaTitle : ''}
${metaDescription ? '\nDescription: ' + metaDescription : ''}
${metaSlug ? '\nSlug: ' + metaSlug : ''}
--- END CONTENT ---`;

                statusText.textContent = 'Step 3/7: Sending request to API...';
                moveProgress(30);

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [
                            {
                                role: 'system',
                                content: "You are an expert content analyst. Provide detailed E-E-A-T evaluation with scores and chunkability assessment. Use the exact section headers requested and format clearly with markdown. Use bullet points, numbered lists, and proper formatting for better readability. CRITICAL: Completely ignore all images, graphics, and visual elements in your analysis - focus exclusively on textual content and structure. Do not penalize content for any image-related issues."
                            },
                            { role: 'user', content: prompt }
                        ],
                        temperature: 0.5,
                        max_tokens: 8000
                    })
                });

                statusText.textContent = 'Step 4/7: Processing response...';
                moveProgress(60);

                if (!response.ok) {
                    let errorBody = 'Could not retrieve error details';
                    try {
                        const errorData = await response.json();
                        errorBody = errorData.error?.message || JSON.stringify(errorData);
                    } catch (e) { /* Ignore */ }
                    throw new Error(`API Error ${response.status}: ${response.statusText}. Details: ${errorBody}`);
                }

                const data = await response.json();
                if (!data.choices?.[0]?.message?.content) {
                    throw new Error('API response did not contain analysis content');
                }

                statusText.textContent = 'Step 5/7: Parsing results...';
                moveProgress(75);

                const markdown = data.choices[0].message.content;
                console.log('Full API Response:', markdown); // Debug log

                // Split the response into content analysis and chunkability sections
                const contentAnalysis = extractContentAnalysis(markdown);
                const chunkabilityAnalysis = extractChunkabilityAnalysis(markdown);

                console.log('Content Analysis:', contentAnalysis); // Debug log
                console.log('Chunkability Analysis:', chunkabilityAnalysis); // Debug log

                statusText.textContent = 'Step 6/7: Displaying results...';
                moveProgress(90);

                // Clear loading interval before displaying results
                if (loadingIntervalId) {
                    clearInterval(loadingIntervalId);
                    loadingIntervalId = null;
                }

                // Display content analysis
                if (contentAnalysis && contentAnalysis.trim()) {
                    console.log('Content Analysis extracted length:', contentAnalysis.length);
                    console.log('Content Analysis contains Note:', contentAnalysis.includes('Note:'));
                    displayResults(contentAnalysis);
                } else {
                    // Fallback: display the full response if we can't extract properly
                    console.log('Full markdown length:', markdown.length);
                    console.log('Full markdown contains Note:', markdown.includes('Note:'));
                    displayResults(markdown);
                    console.warn('Could not extract content analysis section, displaying full response');
                }

                // Display chunkability analysis
                const chunkabilityContainer = document.getElementById('chunkabilityResults');
                if (chunkabilityAnalysis && chunkabilityAnalysis.trim()) {
                    if (window.marked && marked.parse) {
                        const chunkHtml = marked.parse(chunkabilityAnalysis);
                        const processedChunk = generateNavigation(chunkHtml, chunkNavLinks, 'chunk');
                        chunkabilityContainer.innerHTML = processedChunk;
                        
                        // Apply warning styling to notes
                        applyWarningNoteStyling(chunkabilityContainer);
                        
                        chunkNav.classList.add('has-results');
                    } else {
                        chunkabilityContainer.innerHTML = `<pre>${chunkabilityAnalysis}</pre>`;
                        applyWarningNoteStyling(chunkabilityContainer);
                    }
                } else {
                    // Fallback: look for any chunkability content in the full response
                    const fallbackChunk = extractFallbackChunkability(markdown);
                    if (fallbackChunk) {
                        if (window.marked && marked.parse) {
                            const chunkHtml = marked.parse(fallbackChunk);
                            const processedChunk = generateNavigation(chunkHtml, chunkNavLinks, 'chunk');
                            chunkabilityContainer.innerHTML = processedChunk;
                            
                            // Apply warning styling to notes
                            applyWarningNoteStyling(chunkabilityContainer);
                            
                            chunkNav.classList.add('has-results');
                        } else {
                            chunkabilityContainer.innerHTML = `<pre>${fallbackChunk}</pre>`;
                            applyWarningNoteStyling(chunkabilityContainer);
                        }
                    } else {
                        chunkabilityContainer.innerHTML = '<p style="text-align:center; color:#888;">No chunkability analysis found in response.</p>';
                    }
                    console.warn('Could not extract chunkability section properly');
                }

                statusText.textContent = 'Analysis complete!';
                moveProgress(100);
                document.title = 'Analysis Complete';

            } catch (err) {
                console.error("Analysis Error:", err);
                showError(`Error during analysis: ${err.message}`);
                document.title = 'E-E-A-T & Helpful Content Analyzer';
            } finally {
                if (loadingIntervalId) {
                    clearInterval(loadingIntervalId);
                    loadingIntervalId = null;
                }
                resetState();
                await sleep(500);
                if (errorMessageDiv.style.display === 'none') {
                    progressContainer.style.display = 'none';
                }
            }
        }

        function extractContentAnalysis(markdown) {
            // Simple and fast extraction
            const chunkabilityIndex = markdown.indexOf('## Chunkability Analysis');
            if (chunkabilityIndex !== -1) {
                return markdown.substring(0, chunkabilityIndex).trim();
            }

            // Alternative patterns (case insensitive)
            const altIndex = markdown.toLowerCase().indexOf('## chunkability');
            if (altIndex !== -1) {
                return markdown.substring(0, altIndex).trim();
            }

            return markdown; // Return full markdown if no chunkability section found
        }

        function extractChunkabilityAnalysis(markdown) {
            const lowerMarkdown = markdown.toLowerCase();
            
            // Try primary pattern first
            let index = lowerMarkdown.indexOf('## chunkability analysis');
            if (index !== -1) {
                return markdown.substring(index).trim();
            }

            // Try alternative patterns
            const patterns = ['## chunkability', '# chunkability', 'chunkability analysis'];
            for (const pattern of patterns) {
                index = lowerMarkdown.indexOf(pattern);
                if (index !== -1) {
                    return markdown.substring(index).trim();
                }
            }

            return null;
        }

        function extractFallbackChunkability(markdown) {
            // Look for any content that mentions chunkability-related terms
            const lines = markdown.split('\n');
            let chunkabilityContent = '';
            let foundChunkabilityContent = false;

            for (const line of lines) {
                const lowerLine = line.toLowerCase();
                if (lowerLine.includes('chunk') || lowerLine.includes('retriev') ||
                    lowerLine.includes('heading alignment') || lowerLine.includes('entity coverage') ||
                    lowerLine.includes('topical focus') || lowerLine.includes('llm')) {
                    foundChunkabilityContent = true;
                    chunkabilityContent += line + '\n';
                } else if (foundChunkabilityContent && line.trim() === '') {
                    chunkabilityContent += line + '\n';
                } else if (foundChunkabilityContent && line.startsWith('#')) {
                    // New section started, continue collecting if it seems related
                    chunkabilityContent += line + '\n';
                } else if (foundChunkabilityContent) {
                    chunkabilityContent += line + '\n';
                }
            }

            return chunkabilityContent.trim() || null;
        }

        // Optimized scroll observer
        let scrollObserver = null;
        function setupScrollObserver() {
            // Clean up existing observer
            if (scrollObserver) {
                scrollObserver.disconnect();
            }

            const observerOptions = {
                root: null,
                rootMargin: '-20% 0px -70% 0px',
                threshold: 0
            };

            let activeLink = null;
            scrollObserver = new IntersectionObserver((entries) => {
                // Process only the most relevant entry to reduce work
                const visibleEntries = entries.filter(entry => entry.isIntersecting);
                if (visibleEntries.length === 0) return;
                
                // Get the first visible entry (topmost)
                const entry = visibleEntries[0];
                const id = entry.target.id;
                const newActiveLink = document.querySelector(`a[href="#${id}"]`);
                
                if (newActiveLink && newActiveLink !== activeLink) {
                    if (activeLink) activeLink.classList.remove('active');
                    newActiveLink.classList.add('active');
                    activeLink = newActiveLink;
                }
            }, observerOptions);

            // Observe headings more efficiently
            requestAnimationFrame(() => {
                document.querySelectorAll('h2[id], h3[id]').forEach(heading => {
                    scrollObserver.observe(heading);
                });
            });
        }

        // Optimized results observer
        document.addEventListener('DOMContentLoaded', () => {
            let observerTimeout = null;
            const resultsObserver = new MutationObserver((mutations) => {
                // Debounce observer calls to reduce CPU usage
                if (observerTimeout) clearTimeout(observerTimeout);
                observerTimeout = setTimeout(() => {
                    const hasResults = contentNav.classList.contains('has-results') || 
                                     chunkNav.classList.contains('has-results');
                    if (hasResults) {
                        setupScrollObserver();
                    }
                }, 100);
            });

            resultsObserver.observe(document.body, {
                childList: false,
                subtree: false,
                attributes: true,
                attributeFilter: ['class']
            });
        });
    </script>
</body>

</html>