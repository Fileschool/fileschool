<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Filestack Code Generator - RAG-Powered</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        .ai-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: 'Montserrat', sans-serif;
        }
        
        .ai-header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
        }
        
        .ai-header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 900;
        }
        
        .ai-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .ai-input-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .ai-input-group {
            margin-bottom: 20px;
        }
        
        .ai-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 700;
            color: #333;
        }
        
        .ai-input-group textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .ai-input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .ai-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .ai-option {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .ai-option:hover {
            border-color: #667eea;
            background: #e8f0fe;
        }
        
        .ai-option.selected {
            border-color: #667eea;
            background: #e8f0fe;
        }
        
        .ai-option input[type="checkbox"] {
            margin-right: 10px;
        }
        
        .ai-generate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.3s ease;
            width: 100%;
        }
        
        .ai-generate-btn:hover {
            transform: translateY(-2px);
        }
        
        .ai-generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .ai-output-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: none;
        }
        
        .ai-output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e1e5e9;
        }
        
        .ai-output-header h3 {
            margin: 0;
            color: #333;
            font-size: 1.5rem;
        }
        
        .ai-copy-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }
        
        .ai-copy-btn:hover {
            background: #218838;
        }
        
        .ai-code-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .ai-loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .ai-loading i {
            font-size: 2rem;
            margin-bottom: 15px;
            color: #667eea;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .ai-error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #f5c6cb;
            margin-bottom: 20px;
        }
        
        .ai-success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #c3e6cb;
            margin-bottom: 20px;
        }
        
        .ai-tabs {
            display: flex;
            border-bottom: 2px solid #e1e5e9;
            margin-bottom: 20px;
        }
        
        .ai-tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .ai-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .ai-tab-content {
            display: none;
        }
        
        .ai-tab-content.active {
            display: block;
        }
        
        .ai-context-info {
            background: #e8f0fe;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .ai-context-info h4 {
            margin: 0 0 10px 0;
            color: #0056b3;
        }
        
        .ai-context-info ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .ai-context-info li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="ai-container">
        <div class="ai-header">
            <h1><i class="fas fa-robot"></i> AI Filestack Code Generator</h1>
            <p>Powered by RAG (Retrieval-Augmented Generation) - Analyzes your HTML and Filestack documentation to generate precise code configurations</p>
        </div>

        <div class="ai-input-section">
            <div class="ai-input-group">
                <label for="openaiKey">
                    <i class="fas fa-key"></i> OpenAI API Key:
                </label>
                <input type="password" id="openaiKey" placeholder="Enter your OpenAI API key" style="width: 100%; padding: 15px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 16px; margin-bottom: 20px;">
                <small style="color: #666; display: block; margin-bottom: 20px;">
                    <i class="fas fa-info-circle"></i> Your API key is stored locally and never sent to our servers. It's only used to call OpenAI's API directly from your browser.
                </small>
            </div>
            
            <div class="ai-input-group">
                <label for="aiQuery">
                    <i class="fas fa-comment"></i> Describe what you want to configure:
                </label>
                <textarea id="aiQuery" placeholder="Example: Configure a quick picker configuration for me for a CMS that accepts images and PDFs, with drag and drop support, and image previews. Make it secure with authentication."></textarea>
            </div>

            <div class="ai-options">
                <div class="ai-option" onclick="toggleOption(this)">
                    <input type="checkbox" id="includeHtml" checked>
                    <label for="includeHtml">Include HTML snippets</label>
                </div>
                <div class="ai-option" onclick="toggleOption(this)">
                    <input type="checkbox" id="includeJs" checked>
                    <label for="includeJs">Include JavaScript code</label>
                </div>
                <div class="ai-option" onclick="toggleOption(this)">
                    <input type="checkbox" id="includeTypes" checked>
                    <label for="includeTypes">Include TypeScript types</label>
                </div>
                <div class="ai-option" onclick="toggleOption(this)">
                    <input type="checkbox" id="includeExamples" checked>
                    <label for="includeExamples">Include usage examples</label>
                </div>
            </div>

            <button class="ai-generate-btn" onclick="generateCode()" id="generateBtn">
                <i class="fas fa-magic"></i> Generate Code with AI
            </button>
        </div>

        <div class="ai-output-section" id="outputSection">
            <div class="ai-output-header">
                <h3><i class="fas fa-code"></i> Generated Code</h3>
                <button class="ai-copy-btn" onclick="copyGeneratedCode()">
                    <i class="fas fa-copy"></i> Copy Code
                </button>
            </div>

                    <div class="ai-tabs">
            <button class="ai-tab active" onclick="switchTab('code')">Code</button>
            <button class="ai-tab" onclick="switchTab('explanation')">Explanation</button>
            <button class="ai-tab" onclick="switchTab('recommendations')">AI Recommendations</button>
            <button class="ai-tab" onclick="switchTab('context')">Context Used</button>
        </div>

            <div class="ai-tab-content active" id="codeTab">
                <div class="ai-code-output" id="generatedCode">
                    // Your generated code will appear here
                </div>
            </div>

            <div class="ai-tab-content" id="explanationTab">
                <div id="explanationContent">
                    // Explanation will appear here
                </div>
            </div>

                    <div class="ai-tab-content" id="recommendationsTab">
            <div id="recommendationsContent">
                // AI recommendations will appear here
            </div>
        </div>

        <div class="ai-tab-content" id="contextTab">
            <div id="contextContent">
                // Context information will appear here
            </div>
        </div>
        </div>

        <div class="ai-context-info">
            <h4><i class="fas fa-info-circle"></i> What this AI system analyzes:</h4>
            <ul>
                <li><strong>Your HTML file:</strong> All Filestack configuration options, UI components, and code snippets</li>
                <li><strong>Filestack documentation:</strong> Complete API reference, interfaces, classes, and examples from 135+ structured files</li>
                <li><strong>Code patterns:</strong> Best practices, common configurations, and real-world usage examples</li>
                <li><strong>Type definitions:</strong> Full TypeScript interfaces for accurate parameter suggestions</li>
            </ul>
            
            <div id="vectorStatus" style="margin-top: 15px; padding: 10px; border-radius: 5px; background: #f8f9fa; border: 1px solid #dee2e6;">
                <h5><i class="fas fa-database"></i> Vector Database Status</h5>
                <p id="vectorStatusText">Checking connection...</p>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let filestackDocs = {};
        let htmlContent = '';
        let isGenerating = false;

        // Initialize the system
        document.addEventListener('DOMContentLoaded', function() {
            loadFilestackDocumentation();
            loadHtmlContent();
            checkVectorDatabaseStatus();
        });

        // Load Filestack documentation from structured folder
        async function loadFilestackDocumentation() {
            try {
                console.log('Loading Filestack documentation...');
                
                // Load key documentation files
                const keyFiles = [
                    'filestack-js__interfaces__TransformOptions.html.json',
                    'filestack-js__classes__Client.html.json',
                    'filestack-js__classes__Filelink.html.json',
                    'filestack-js__interfaces__ClientOptions.html.json',
                    'filestack-js__interfaces__PickerOptions.html.json',
                    'filestack-js__interfaces__UploadOptions.html.json',
                    'filestack-js__interfaces__SecurityOptions.html.json'
                ];

                for (const file of keyFiles) {
                    try {
                        const response = await fetch(`complete_filestack_js/structured/${file}`);
                        if (response.ok) {
                            const data = await response.json();
                            filestackDocs[file] = data;
                        }
                    } catch (error) {
                        console.warn(`Could not load ${file}:`, error);
                    }
                }

                // Load additional files in batches for comprehensive coverage
                await loadBatchDocumentation();
                
                console.log('Filestack documentation loaded successfully');
            } catch (error) {
                console.error('Error loading Filestack documentation:', error);
            }
        }

        // Load documentation in batches for efficiency
        async function loadBatchDocumentation() {
            const batchSize = 10;
            const allFiles = [
                'filestack-js__interfaces__ResizeParams.html.json',
                'filestack-js__interfaces__CropParams.html.json',
                'filestack-js__interfaces__RotateParams.html.json',
                'filestack-js__interfaces__BlurParams.html.json',
                'filestack-js__interfaces__SharpenParams.html.json',
                'filestack-js__interfaces__SepiaParams.html.json',
                'filestack-js__interfaces__BorderParams.html.json',
                'filestack-js__interfaces__WatermarkParams.html.json',
                'filestack-js__interfaces__ShadowParams.html.json',
                'filestack-js__interfaces__VignetteParams.html.json',
                'filestack-js__interfaces__MetadataOptions.html.json',
                'filestack-js__interfaces__StoreBaseParams.html.json',
                'filestack-js__interfaces__SecurityParams.html.json',
                'filestack-js__interfaces__DetectFacesParams.html.json'
            ];

            for (let i = 0; i < allFiles.length; i += batchSize) {
                const batch = allFiles.slice(i, i + batchSize);
                await Promise.allSettled(
                    batch.map(async (file) => {
                        try {
                            const response = await fetch(`complete_filestack_js/structured/${file}`);
                            if (response.ok) {
                                const data = await response.json();
                                filestackDocs[file] = data;
                            }
                        } catch (error) {
                            // Silently handle individual file errors
                        }
                    })
                );
                
                // Small delay between batches to avoid overwhelming the system
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // Load HTML content
        async function loadHtmlContent() {
            try {
                const response = await fetch('index.html');
                if (response.ok) {
                    htmlContent = await response.text();
                    console.log('HTML content loaded successfully');
                }
            } catch (error) {
                console.error('Error loading HTML content:', error);
            }
        }

        // Check vector database status
        async function checkVectorDatabaseStatus() {
            const statusElement = document.getElementById('vectorStatusText');
            const statusContainer = document.getElementById('vectorStatus');
            
            try {
                const response = await fetch('http://localhost:6333/collections');
                if (response.ok) {
                    const collections = await response.json();
                    const hasFilestackCollection = collections.collections.some(c => c.name === 'filestack_docs');
                    
                    if (hasFilestackCollection) {
                        statusElement.innerHTML = '<span style="color: #28a745;">✅ Connected - Filestack docs indexed and ready for semantic search!</span>';
                        statusContainer.style.background = '#d4edda';
                        statusContainer.style.borderColor = '#c3e6cb';
                    } else {
                        statusElement.innerHTML = '<span style="color: #ffc107;">⚠️ Connected - No Filestack docs indexed yet. Run the indexer first.</span>';
                        statusContainer.style.background = '#fff3cd';
                        statusContainer.style.borderColor = '#ffeaa7';
                    }
                } else {
                    throw new Error('Qdrant not responding');
                }
            } catch (error) {
                statusElement.innerHTML = '<span style="color: #dc3545;">❌ Not connected - Start Qdrant with: docker-compose up -d</span>';
                statusContainer.style.background = '#f8d7da';
                statusContainer.style.borderColor = '#f5c6cb';
            }
        }

        // Toggle option selection
        function toggleOption(element) {
            const checkbox = element.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            element.classList.toggle('selected', checkbox.checked);
        }

        // Switch between tabs
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.ai-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.ai-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Generate code using AI
        async function generateCode() {
            if (isGenerating) return;
            
            const openaiKey = document.getElementById('openaiKey').value.trim();
            if (!openaiKey) {
                alert('Please enter your OpenAI API key.');
                return;
            }
            
            const query = document.getElementById('aiQuery').value.trim();
            if (!query) {
                alert('Please enter a description of what you want to configure.');
                return;
            }

            isGenerating = true;
            const generateBtn = document.getElementById('generateBtn');
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';

            // Show output section
            document.getElementById('outputSection').style.display = 'block';
            
            // Show loading state
            document.getElementById('generatedCode').innerHTML = '<div class="ai-loading"><i class="fas fa-spinner"></i><br>AI is analyzing your request and generating code...</div>';

            try {
                // Prepare context from both HTML and Filestack docs
                const context = prepareContext(query);
                
                // Generate code using OpenAI API
                const result = await generateCodeWithOpenAI(query, context, openaiKey);
                
                // Display results
                displayResults(result);
                
            } catch (error) {
                console.error('Error generating code:', error);
                document.getElementById('generatedCode').innerHTML = 
                    '<div class="ai-error"><i class="fas fa-exclamation-triangle"></i> Error generating code: ' + error.message + '</div>';
            } finally {
                isGenerating = false;
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<i class="fas fa-magic"></i> Generate Code with AI';
            }
        }

        // Enhanced context preparation using vector database
        async function prepareContext(query) {
            const context = {
                html: {},
                filestack: {},
                relevantCode: [],
                vectorSearchResults: []
            };

            // Extract relevant HTML content
            if (document.getElementById('includeHtml').checked && htmlContent) {
                context.html = extractHtmlContext(query);
            }

            // Use vector database for Filestack documentation if available
            if (document.getElementById('includeJs').checked) {
                try {
                    const vectorContext = await getVectorContext(query);
                    context.filestack = vectorContext.filestack;
                    context.relevantCode = [...context.relevantCode, ...vectorContext.relevantCode];
                    context.vectorSearchResults = vectorContext.vectorSearchResults;
                } catch (error) {
                    console.warn('Vector search failed, falling back to local search:', error);
                    // Fallback to local search
                    if (Object.keys(filestackDocs).length > 0) {
                        context.filestack = extractFilestackContext(query);
                    }
                }
            }

            // Find relevant code snippets from HTML
            const htmlSnippets = findRelevantCodeSnippets(query, context);
            context.relevantCode = [...context.relevantCode, ...htmlSnippets];

            return context;
        }

        // Get context from vector database
        async function getVectorContext(query, limit = 15) {
            try {
                // Check if Qdrant is available
                const qdrantResponse = await fetch('http://localhost:6333/collections');
                if (!qdrantResponse.ok) {
                    throw new Error('Qdrant not available');
                }

                // Generate embedding for the query using OpenAI
                const embeddingResponse = await fetch('https://api.openai.com/v1/embeddings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${document.getElementById('openaiKey').value}`
                    },
                    body: JSON.stringify({
                        model: 'text-embedding-3-large',
                        input: query
                    })
                });

                if (!embeddingResponse.ok) {
                    throw new Error('Failed to generate embedding');
                }

                const embeddingData = await embeddingResponse.json();
                const queryEmbedding = embeddingData.data[0].embedding;

                // Search in Qdrant
                const searchResponse = await fetch(`http://localhost:6333/collections/filestack_docs/points/search`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        vector: queryEmbedding,
                        limit: limit,
                        with_payload: true,
                        with_vectors: false
                    })
                });

                if (!searchResponse.ok) {
                    throw new Error('Vector search failed');
                }

                const searchResults = await searchResponse.json();
                
                // Format results for AI context
                const vectorContext = {
                    filestack: {
                        interfaces: {},
                        classes: {},
                        examples: [],
                        types: {}
                    },
                    relevantCode: [],
                    vectorSearchResults: []
                };

                // Process search results
                searchResults.result.forEach(result => {
                    const payload = result.payload;
                    
                    // Add to vector search results
                    vectorContext.vectorSearchResults.push({
                        title: payload.title,
                        category: payload.category,
                        filename: payload.filename,
                        content: payload.content,
                        relevance: result.score,
                        chunk: payload.chunk_index + 1,
                        totalChunks: payload.total_chunks
                    });
                    
                    // Categorize by type
                    if (payload.filename.includes('__interfaces__')) {
                        vectorContext.filestack.interfaces[payload.filename] = {
                            title: payload.title,
                            category: payload.category,
                            content: payload.content,
                            relevance: result.score
                        };
                    } else if (payload.filename.includes('__classes__')) {
                        vectorContext.filestack.classes[payload.filename] = {
                            title: payload.title,
                            category: payload.category,
                            content: payload.content,
                            relevance: result.score
                        };
                    }
                    
                    // Extract code snippets if present
                    if (payload.content.includes('```') || payload.content.includes('code')) {
                        vectorContext.relevantCode.push({
                            source: `Vector Search - ${payload.filename}`,
                            code: payload.content,
                            language: 'typescript',
                            relevance: result.score
                        });
                    }
                });

                return vectorContext;

            } catch (error) {
                console.error('Vector search error:', error);
                throw error;
            }
        }

        // Extract relevant HTML context
        function extractHtmlContext(query) {
            const context = {
                pickerOptions: {},
                transformOptions: {},
                securityOptions: {},
                uploadOptions: {},
                examples: []
            };

            // Parse HTML to find relevant configuration options
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlContent, 'text/html');

            // Extract picker configuration options
            const pickerSection = doc.querySelector('#picker');
            if (pickerSection) {
                // Extract file acceptance options
                const fileCheckboxes = pickerSection.querySelectorAll('input[type="checkbox"]');
                fileCheckboxes.forEach(checkbox => {
                    if (checkbox.value) {
                        context.pickerOptions[checkbox.value] = checkbox.nextElementSibling.textContent;
                    }
                });

                // Extract display modes
                const displayModes = pickerSection.querySelectorAll('input[name="displayMode"]');
                displayModes.forEach(radio => {
                    context.pickerOptions.displayModes = context.pickerOptions.displayModes || [];
                    context.pickerOptions.displayModes.push(radio.value);
                });

                // Extract file limits
                const maxFiles = pickerSection.querySelector('#maxFiles');
                const maxSize = pickerSection.querySelector('#maxSize');
                if (maxFiles) context.pickerOptions.maxFiles = maxFiles.placeholder;
                if (maxSize) context.pickerOptions.maxSize = maxSize.placeholder;
            }

            // Extract transform options
            const transformSection = doc.querySelector('#transform');
            if (transformSection) {
                const transformCheckboxes = transformSection.querySelectorAll('input[type="checkbox"]');
                transformCheckboxes.forEach(checkbox => {
                    if (checkbox.id && checkbox.id.startsWith('enable')) {
                        const transformName = checkbox.id.replace('enable', '').toLowerCase();
                        context.transformOptions[transformName] = true;
                    }
                });
            }

            return context;
        }

        // Extract relevant Filestack documentation context
        function extractFilestackContext(query) {
            const context = {
                interfaces: {},
                classes: {},
                examples: [],
                types: {}
            };

            // Search through documentation for relevant information
            Object.entries(filestackDocs).forEach(([filename, doc]) => {
                if (isRelevantToQuery(filename, doc, query)) {
                    if (filename.includes('__interfaces__')) {
                        context.interfaces[filename] = doc;
                    } else if (filename.includes('__classes__')) {
                        context.classes[filename] = doc;
                    }
                }
            });

            return context;
        }

        // Check if documentation is relevant to the query
        function isRelevantToQuery(filename, doc, query) {
            const queryLower = query.toLowerCase();
            const filenameLower = filename.toLowerCase();
            const titleLower = (doc.title || '').toLowerCase();
            
            // Check if filename or title contains relevant keywords
            const relevantKeywords = ['picker', 'upload', 'transform', 'security', 'cms', 'image', 'pdf', 'file'];
            return relevantKeywords.some(keyword => 
                filenameLower.includes(keyword) || titleLower.includes(keyword)
            );
        }

        // Find relevant code snippets
        function findRelevantCodeSnippets(query, context) {
            const snippets = [];
            
            // Extract code from HTML
            if (context.html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(htmlContent, 'text/html');
                
                // Find JavaScript code blocks
                const codeBlocks = doc.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    if (block.textContent.includes('filestack') || block.textContent.includes('picker')) {
                        snippets.push({
                            source: 'HTML',
                            code: block.textContent,
                            language: block.className.replace('language-', '')
                        });
                    }
                });
            }

            // Extract code from Filestack docs
            Object.values(context.filestack.interfaces || {}).forEach(interface => {
                if (interface.sections) {
                    interface.sections.forEach(section => {
                        if (section.code_blocks) {
                            section.code_blocks.forEach(codeBlock => {
                                snippets.push({
                                    source: 'Filestack Docs',
                                    code: codeBlock.code,
                                    language: codeBlock.language || 'typescript'
                                });
                            });
                        }
                    });
                }
            });

            return snippets;
        }

        // Generate code using OpenAI API
        async function generateCodeWithOpenAI(query, context, apiKey) {
            try {
                // Prepare the context data for OpenAI
                const contextData = {
                    html: context.html,
                    filestackDocs: context.filestack,
                    relevantCode: context.relevantCode,
                    query: query
                };
                
                // Create the prompt for OpenAI
                const systemPrompt = `You are an expert Filestack developer. Analyze the provided context and generate precise code configurations based on the user's request.

Context includes:
- HTML configuration options from the user's interface
- Filestack documentation and API references
- Relevant code snippets and examples

Generate code that:
1. Uses the exact Filestack API patterns from the documentation
2. Incorporates relevant configuration options from the HTML
3. Follows best practices and includes proper error handling
4. Is production-ready and well-commented

Respond with a JSON object containing:
{
  "code": "The generated JavaScript/TypeScript code",
  "explanation": "Detailed explanation of what the code does and why",
  "recommendations": "Additional suggestions for improvement"
}`;

                const userPrompt = `User Request: ${query}

Available Context:
${JSON.stringify(contextData, null, 2)}

Please generate the appropriate Filestack configuration code.`;

                // Call OpenAI API
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        temperature: 0.3,
                        max_tokens: 2000
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`OpenAI API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                const aiResponse = data.choices[0]?.message?.content;
                
                // Parse the AI response
                let parsedResponse;
                try {
                    // Try to extract JSON from the response
                    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        parsedResponse = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseError) {
                    // Fallback to manual parsing if JSON parsing fails
                    parsedResponse = {
                        code: aiResponse,
                        explanation: 'AI generated response (parsing failed)',
                        recommendations: 'Check the generated code for accuracy'
                    };
                }

                return {
                    code: parsedResponse.code || aiResponse,
                    explanation: parsedResponse.explanation || 'AI generated explanation',
                    recommendations: parsedResponse.recommendations || '',
                    context: context
                };

            } catch (error) {
                console.error('OpenAI API call failed:', error);
                throw new Error(`Failed to generate code with AI: ${error.message}`);
            }
        }

        // Generate actual code from context
        function generateCodeFromContext(query, context) {
            let code = '';
            
            // Generate picker configuration
            if (query.toLowerCase().includes('picker')) {
                code += generatePickerCode(context);
            }
            
            // Generate transform configuration
            if (query.toLowerCase().includes('transform') || query.toLowerCase().includes('image')) {
                code += generateTransformCode(context);
            }
            
            // Generate security configuration
            if (query.toLowerCase().includes('secure') || query.toLowerCase().includes('security')) {
                code += generateSecurityCode(context);
            }
            
            // Generate upload configuration
            if (query.toLowerCase().includes('upload') || query.toLowerCase().includes('cms')) {
                code += generateUploadCode(context);
            }
            
            return code || '// No specific configuration found for your request. Please try a more specific query.';
        }

        // Generate picker code
        function generatePickerCode(context) {
            let code = '// Filestack Picker Configuration\n';
            code += 'const pickerOptions = {\n';
            
            if (context.html.pickerOptions) {
                if (context.html.pickerOptions.displayModes) {
                    code += '  displayMode: "modal", // Options: modal, inline, dropPane\n';
                }
                
                if (context.html.pickerOptions.maxFiles) {
                    code += `  maxFiles: ${context.html.pickerOptions.maxFiles},\n`;
                }
                
                if (context.html.pickerOptions.maxSize) {
                    code += `  maxSize: ${context.html.pickerOptions.maxSize} * 1024 * 1024, // Convert MB to bytes\n`;
                }
                
                // Add file acceptance
                const fileTypes = Object.keys(context.html.pickerOptions).filter(key => 
                    key.includes('image') || key.includes('pdf') || key.includes('video')
                );
                if (fileTypes.length > 0) {
                    code += '  accept: [\n';
                    fileTypes.forEach(type => {
                        code += `    "${type}",\n`;
                    });
                    code += '  ],\n';
                }
            }
            
            code += '  sources: ["local", "url", "googledrive", "dropbox"],\n';
            code += '  onFileSelected: (result) => {\n';
            code += '    console.log("Files selected:", result.filesUploaded);\n';
            code += '  },\n';
            code += '  onUploadDone: (result) => {\n';
            code += '    console.log("Upload completed:", result);\n';
            code += '  }\n';
            code += '};\n\n';
            
            code += '// Initialize picker\n';
            code += 'const client = filestack.init("YOUR_API_KEY");\n';
            code += 'const picker = client.picker(pickerOptions);\n';
            code += 'picker.open();\n';
            
            return code;
        }

        // Generate transform code
        function generateTransformCode(context) {
            let code = '// Filestack Image Transform Configuration\n';
            code += 'const transformOptions = {\n';
            
            if (context.html.transformOptions) {
                if (context.html.transformOptions.resize) {
                    code += '  resize: {\n';
                    code += '    width: 800,\n';
                    code += '    height: 600,\n';
                    code += '    fit: "clip"\n';
                    code += '  },\n';
                }
                
                if (context.html.transformOptions.crop) {
                    code += '  crop: {\n';
                    code += '    x: 0,\n';
                    code += '    y: 0,\n';
                    code += '    width: 400,\n';
                    code += '    height: 300\n';
                    code += '  },\n';
                }
                
                if (context.html.transformOptions.blur) {
                    code += '  blur: 5,\n';
                }
                
                if (context.html.transformOptions.rotate) {
                    code += '  rotate: 90,\n';
                }
            }
            
            code += '  output: {\n';
            code += '    format: "jpg",\n';
            code += '    quality: 80\n';
            code += '  }\n';
            code += '};\n\n';
            
            code += '// Apply transforms\n';
            code += 'const transformedUrl = client.transform("FILE_HANDLE", transformOptions);\n';
            
            return code;
        }

        // Generate security code
        function generateSecurityCode(context) {
            let code = '// Filestack Security Configuration\n';
            code += 'const securityOptions = {\n';
            code += '  policy: "YOUR_SECURITY_POLICY",\n';
            code += '  signature: "YOUR_SECURITY_SIGNATURE",\n';
            code += '  expiry: Math.floor(Date.now() / 1000) + 3600 // 1 hour from now\n';
            code += '};\n\n';
            
            code += '// Initialize client with security\n';
            code += 'const client = filestack.init("YOUR_API_KEY", {\n';
            code += '  security: securityOptions\n';
            code += '});\n';
            
            return code;
        }

        // Generate upload code
        function generateUploadCode(context) {
            let code = '// Filestack Upload Configuration for CMS\n';
            code += 'const uploadOptions = {\n';
            code += '  path: "/uploads/cms/",\n';
            code += '  access: "public",\n';
            code += '  tags: ["cms", "user-upload"],\n';
            code += '  onProgress: (progress) => {\n';
            code += '    console.log("Upload progress:", progress);\n';
            code += '  },\n';
            code += '  onError: (error) => {\n';
            code += '    console.error("Upload error:", error);\n';
            code += '  }\n';
            code += '};\n\n';
            
            code += '// Upload file\n';
            code += 'const uploadResult = await client.upload(file, uploadOptions);\n';
            code += 'console.log("Upload successful:", uploadResult);\n';
            
            return code;
        }

        // Generate explanation
        function generateExplanation(query, context) {
            let explanation = '<h4>Code Explanation</h4>';
            explanation += '<p>This code was generated based on your request: <strong>"' + query + '"</strong></p>';
            
            if (context.html.pickerOptions) {
                explanation += '<h5>Picker Configuration</h5>';
                explanation += '<ul>';
                explanation += '<li>Display mode set to modal for better user experience</li>';
                explanation += '<li>File limits configured based on your HTML settings</li>';
                explanation += '<li>Multiple sources enabled for flexibility</li>';
                explanation += '</ul>';
            }
            
            if (context.html.transformOptions) {
                explanation += '<h5>Transform Options</h5>';
                explanation += '<ul>';
                explanation += '<li>Image transformations configured based on your requirements</li>';
                explanation += '<li>Output format and quality optimized for web use</li>';
                explanation += '</ul>';
            }
            
            explanation += '<h5>Security Features</h5>';
            explanation += '<ul>';
            explanation += '<li>API key authentication implemented</li>';
            explanation += '<li>Security policy and signature support included</li>';
            explanation += '<li>Expiry time set for enhanced security</li>';
            explanation += '</ul>';
            
            return explanation;
        }

        // Display results
        function displayResults(result) {
            // Display generated code
            document.getElementById('generatedCode').innerHTML = result.code;
            
            // Display explanation
            document.getElementById('explanationContent').innerHTML = result.explanation;
            
            // Display AI recommendations
            if (result.recommendations) {
                document.getElementById('recommendationsContent').innerHTML = 
                    '<h4><i class="fas fa-lightbulb"></i> AI Recommendations</h4>' + 
                    '<div style="background: #e8f5e8; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745;">' +
                    result.recommendations +
                    '</div>';
            } else {
                document.getElementById('recommendationsContent').innerHTML = 
                    '<p>No specific recommendations provided by AI.</p>';
            }
            
            // Display context information
            let contextInfo = '<h4>Context Used</h4>';
            contextInfo += '<p><strong>HTML Analysis:</strong> ' + (Object.keys(result.context.html).length > 0 ? 'Yes' : 'No') + '</p>';
            contextInfo += '<p><strong>Filestack Documentation:</strong> ' + (Object.keys(result.context.filestack).length > 0 ? 'Yes' : 'No') + '</p>';
            contextInfo += '<p><strong>Code Snippets Found:</strong> ' + result.context.relevantCode.length + '</p>';
            
            // Show vector search results if available
            if (result.context.vectorSearchResults && result.context.vectorSearchResults.length > 0) {
                contextInfo += '<h5>🔍 Vector Search Results:</h5>';
                contextInfo += '<p><strong>Total Results:</strong> ' + result.context.vectorSearchResults.length + '</p>';
                
                // Show top 3 most relevant results
                const topResults = result.context.vectorSearchResults.slice(0, 3);
                contextInfo += '<h6>Top Results:</h6><ul>';
                topResults.forEach((result, index) => {
                    contextInfo += `<li><strong>${result.title}</strong> (${result.category})`;
                    contextInfo += `<br>📁 File: ${result.filename}`;
                    contextInfo += `<br>🎯 Relevance: ${(result.relevance * 100).toFixed(1)}%`;
                    contextInfo += `<br>📄 Content: ${result.content.substring(0, 100)}...</li>`;
                });
                contextInfo += '</ul>';
            }
            
            if (result.context.relevantCode.length > 0) {
                contextInfo += '<h5>Relevant Sources:</h5><ul>';
                result.context.relevantCode.forEach(snippet => {
                    contextInfo += '<li>' + snippet.source + ' (' + snippet.language + ')</li>';
                });
                contextInfo += '</ul>';
            }
            
            document.getElementById('contextContent').innerHTML = contextInfo;
        }

        // Copy generated code
        function copyGeneratedCode() {
            const codeElement = document.getElementById('generatedCode');
            const text = codeElement.textContent || codeElement.innerText;
            
            navigator.clipboard.writeText(text).then(() => {
                const copyBtn = document.querySelector('.ai-copy-btn');
                const originalText = copyBtn.innerHTML;
                copyBtn.innerHTML = '<i class="fas fa-check"></i> Copied!';
                copyBtn.style.background = '#28a745';
                
                setTimeout(() => {
                    copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy Code';
                    copyBtn.style.background = '#28a745';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy code:', err);
                alert('Failed to copy code to clipboard');
            });
        }
    </script>
</body>
</html>
